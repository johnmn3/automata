#Mon Feb 14 01:21:11 EST 2011
cmdhistory=["(defn chunkify2 [the-state chunk-size]\\n  (let [width (+ 2 (int (/ (count the-state) chunk-size)))]\\n    (vec (pmap \#(wrap-sub the-state % width) \\n           (range (- (int (/ width 2)) 1)\\n             (count the-state) (- width 2))))))" "(chunkify2 nums 10)" "(chunkify2 nums 6)" "(chunkify2 nums 3)" "(chunkify2 nums 4)" "(chunkify2 nums 5)" "(chunkify2 nums 6)" "(chunkify2 nums 7)" "(chunkify2 nums 8)" "(chunkify2 nums 9)" "(chunkify2 nums 10)" "(chunkify2 nums 2)" "(chunkify2 nums 11)" "(chunkify2 nums 12)" "(chunkify2 nums 13)" "(chunkify2 nums 14)" "(chunkify2 nums 15)" "(chunkify2 nums 16)" "(chunkify2 nums 17)" "(chunkify2 nums 18)" "(chunkify2 nums 19)" "(chunkify2 nums 20)" "(chunkify2 nums 21)" "(chunkify2 nums 22)" "(chunkify2 nums 23)" "(chunkify2 nums 24)" "(chunkify2 nums 25)" "(chunkify2 nums 26)" "(chunkify2 nums 27)" "(chunkify2 nums 30)" "(chunkify2 nums 40)" "(chunkify2 nums 49)" "(chunkify2 nums 13)" "(chunkify2 nums 5)" "(chunkify2 nums 6)" "(range (- (int (/ 6 2)) 1) (count nums) (- width 2))" "(range (- (int (/ 6 2)) 1) (count nums) (- (+2 (int (/ (count nums) 6))) 2))" "(range (- (int (/ 6 2)) 1) (count nums) (- (+ 2 (int (/ (count nums) 6))) 2))" "(defn get-range [c s] (range (- (int (/ c 2)) 1) (count s) (- (+ 2 (int (/ (count s) c))) 2)))" "(get-range 6 nums)" "(defn get-range [s c] (get-range c s))" "(get-range nums 6)" "(get-range 6 nums)" "(defn get-range [s c] (range (- (int (/ c 2)) 1) (count s) (- (+ 2 (int (/ (count s) c))) 2)))" "(get-range 6 nums)" "(get-range nums 6)" "(get-range nums 5)" "(get-range nums 4)" "(get-range nums 3)" "(get-range nums 2)" "(get-range nums 7)" "(get-range nums 8)" "(get-range nums 9)" "(get-range nums 10)" "(get-range nums 11)" "(get-range nums 12)" "(get-range nums 13)" "(chunkify2 nums 2)" "(get-range nums 2)" "(chunkify2 nums 3)" "(get-range nums 3)" "(chunkify2 nums 4)" "(get-range nums 4)" "(chunkify2 nums 5)" "(get-range nums 5)" "(chunkify2 nums 6)" "(get-range nums 6)" "(chunkify2 nums 7)" "(get-range nums 7)" "(defn chunkify2 [the-state chunk-size]\\n  (let [width (+ 2 (int (/ (count the-state) chunk-size)))\\n        the-range (range (- (int (/ width 2)) 1)\\n                    (count the-state) (- width 2))]\\n    (vec (pmap \#(wrap-sub the-state % width) \\n           the-range))))" "(chunkify2 nums 7)" "(defn chunkify2 [the-state chunk-size]\\n  (let [width (+ 2 (int (/ (count the-state) chunk-size)))\\n        the-range (range (- (int (/ width 2)) 1)\\n                    (count the-state) (- width 2))]\\n    (vec (pmap \#(wrap-sub the-state % width) \\n           the-range))))" "(chunkify2 nums 7)" "(get-range nums 7)" "(chunkify2 nums 6)" "(get-range nums 6)" "(get-range nums 8)" "(chunkify2 nums 8)" "(chunkify2 nums 9)" "(get-range nums 9)" "(defn get-range [s c] (range (- (int (/ (+ 2 (int (/ (count s) c))) 2)) 1) (count s) (- (+ 2 (int (/ (count s) c))) 2)))" "(get-range nums 9)" "(get-range nums 5)" "(chunkify nums 5)" "(chunkify nums 6)" "(get-range nums 6)" "(chunkify nums 6)" "(get-range nums 7)" "(chunkify nums 7)" "(get-range nums 8)" "(chunkify nums 8)" "(get-range nums 9)" "(chunkify nums 9)" "(int (/ 50 9))" "(chunkify nums 12)" "(defn chunkify2 [the-state chunk-size]\\n  (let [width chunk-size ;(+ 2 (int (/ (count the-state) chunk-size)))\\n        base (- (int (/ width 2)) 1)\\n        the-range (range base\\n                    (count the-state) (- width 2))\\n        new-range (->> the-range\\n                    (drop 1)\\n                    ;if none have 49 on or before the second to the last el on last set\\n                      ; add a new vec with the right stuff\\n                      ; else, if 49 comes before the second to the last el on last set\\n                      ; drop til zero\\n                      ; else, 0 is last?  good to go, rock on]\\n    (vec (pmap \#(wrap-sub the-state % width) \\n           the-range))))" "(defn chunkify2 [the-state chunk-size]\\n  (let [width chunk-size ;(+ 2 (int (/ (count the-state) chunk-size)))\\n        base (- (int (/ width 2)) 1)\\n        the-range (range base\\n                    (count the-state) (- width 2))\\n        new-range (->> the-range\\n                    (drop 1)\\n                    ;if none have 49 on or before the second to the last el on last set\\n                      ; add a new vec with the right stuff\\n                      ; else, if 49 comes before the second to the last el on last set\\n                      ; drop til zero\\n                      ; else, 0 is last?  good to go, rock on\\n                      ]\\n    (vec (pmap \#(wrap-sub the-state % width) \\n           the-range)))))" "(defn chunkify2 [the-state chunk-size]\\n  (let [width chunk-size ;(+ 2 (int (/ (count the-state) chunk-size)))\\n        base (- (int (/ width 2)) 1)\\n        the-range (range base\\n                    (count the-state) (- width 2))\\n        new-range (->> the-range\\n                    (drop 1))\\n                    ;if none have 49 on or before the second to the last el on last set\\n                      ; add a new vec with the right stuff\\n                      ; else, if 49 comes before the second to the last el on last set\\n                      ; drop til zero\\n                      ; else, 0 is last?  good to go, rock on\\n                      ]\\n    (vec (pmap \#(wrap-sub the-state % width) \\n           the-range))))" "(chunkify nums 12)" "(chunkify2 nums 9)" "(chunkify2 nums 3)" "(chunkify2 nums 4)" "(chunkify2 nums 5)" "(chunkify2 nums 6)" "(chunkify2 nums 7)" "(chunkify2 nums 8)" "(chunkify2 nums 9)" "(chunkify2 nums 10)" "(chunkify2 nums 11)" "(defn chunkify2 [the-state chunk-size]\\n  (let [width chunk-size ;(+ 2 (int (/ (count the-state) chunk-size)))\\n        base (- (int (/ width 2)) 1)\\n        the-range (range base\\n                    (+ 1 (count the-state)) \\n                    (- width 2))\\n        new-range (->> the-range\\n                    (drop 1))\\n                    ;if none have 49 on or before the second to the last el on last set\\n                      ; add a new vec with the right stuff\\n                      ; else, if 49 comes before the second to the last el on last set\\n                      ; drop til zero\\n                      ; else, 0 is last?  good to go, rock on\\n                      ]\\n    (vec (pmap \#(wrap-sub the-state % width) \\n           the-range))))" "(chunkify2 nums 11)" "(chunkify2 nums 2)" "(chunkify2 nums 3)" "(chunkify2 nums 4)" "(chunkify2 nums 5)" "(chunkify2 nums 6)" "(chunkify2 nums 7)" "(chunkify2 nums 8)" "(defn chunkify2 [the-state chunk-size]\\n  (let [width chunk-size ;(+ 2 (int (/ (count the-state) chunk-size)))\\n        base (- (int (/ width 2)) 1)\\n        the-range (range base\\n                    (+ 2 (count the-state)) \\n                    (- width 2))\\n        new-range (->> the-range\\n                    (drop 1))\\n                    ;if none have 49 on or before the second to the last el on last set\\n                      ; add a new vec with the right stuff\\n                      ; else, if 49 comes before the second to the last el on last set\\n                      ; drop til zero\\n                      ; else, 0 is last?  good to go, rock on\\n                      ]\\n    (vec (pmap \#(wrap-sub the-state % width) \\n           the-range))))" "(chunkify2 nums 8)" "(chunkify2 nums 2)" "(chunkify2 nums 3)" "(the-range nums 3)" "(therange nums 3)" "(get-range nums 3)" "(defn get-range [s c] (range (- (int (/ c 2)) 1) (count s) (- c 2)))" "(get-range nums 3)" "(get-range nums 4)" "(get-range nums 8)" "(get-range nums 5)" "(get-range nums 6)" "(defn get-range [s c] (range (- (int (/ c 2)) 1) (+ 2 (count s)) (- c 2)))" "(get-range nums 6)" "(get-range nums 8)" "(get-range nums 2)" "(get-range nums 3)" "(get-range nums 4)" "(get-range nums 5)" "(get-range nums 6)" "(get-range nums 7)" "(chunkify nums 7)" "(get-range nums 8)" "(get-range nums 9)" "(chunkify nums 9)" "(chunkify nums 10)" "(chunkify nums 11)" "(chunkify nums 12)" "(chunkify nums 13)" "(chunkify nums 14)" "(chunkify nums 15)" "(chunkify nums 16)" "(chunkify nums 17)" "(chunkify nums 18)" "(count state)" "(count (chunkify state 18))" "(count (chunkify state 100))" "(count (chunkify state 1000))" "(count (chunkify state 10000))" "(count (chunkify2 state 10000))" "(count (chunkify2 state 1000))" "(count (chunkify2 state 100))" "(count (chunkify2 state 10))" "(count (first (chunkify2 state 10)))" "(count (first (chunkify2 state 100)))" "(count (first (chunkify2 state 1000)))" "(count (first (chunkify2 state 10000)))" "(count (first (chunkify2 state 100000)))" "(count (chunkify2 state 100000))" "(last (last (chunkify2 state 100000)))" "(chunkify2 nums 17)" "(chunkify2 nums 6)" "(chunkify2 nums 7)" "(chunkify2 nums 8)" "(chunkify2 nums 9)" "(chunkify nums 9)" "(defn chunkify2 [the-state chunk-size]\\n  (let [width chunk-size ;(+ 2 (int (/ (count the-state) chunk-size)))\\n        base (- (int (/ width 2)) 1)\\n        the-range (range base\\n                    (+ width (count the-state)) \\n                    (- width 2))\\n        new-range (->> the-range\\n                    (drop 1))\\n                    ;if none have 49 on or before the second to the last el on last set\\n                      ; add a new vec with the right stuff\\n                      ; else, if 49 comes before the second to the last el on last set\\n                      ; drop til zero\\n                      ; else, 0 is last?  good to go, rock on\\n                      ]\\n    (vec (pmap \#(wrap-sub the-state % width) \\n           the-range))))" "(chunkify2 nums 9)" "(chunkify2 nums 3)" "(chunkify2 nums 4)" "(chunkify2 nums 5)" "(chunkify2 nums 6)" "(chunkify2 nums 7)" "(chunkify2 nums 8)" "(chunkify2 nums 9)" "(chunkify2 nums 10)" "(chunkify2 nums 11)" "(chunkify2 nums 12)" "(chunkify2 nums 13)" "(chunkify2 nums 20)" "(chunkify2 nums 25)" "(chunkify2 nums 26)" "(defn chunkify2 [the-state chunk-size]\\n  (let [width (+ 2 chunk-size) ;(+ 2 (int (/ (count the-state) chunk-size)))\\n        base (- (int (/ width 2)) 1)\\n        the-range (range base\\n                    (+ width (count the-state)) \\n                    (- width 2))\\n        new-range (->> the-range\\n                    (drop 1))\\n                    ;if none have 49 on or before the second to the last el on last set\\n                      ; add a new vec with the right stuff\\n                      ; else, if 49 comes before the second to the last el on last set\\n                      ; drop til zero\\n                      ; else, 0 is last?  good to go, rock on\\n                      ]\\n    (vec (pmap \#(wrap-sub the-state % width) \\n           the-range))))" "(chunkify2 nums 3)" "(chunkify2 nums 1)" "(chunkify2 nums 2)" "(chunkify2 nums 3)" "(count (chunkify2 nums 3))" "(/ 50.0 3)" "(defn chunkify2 [the-state chunk-size]\\n  (let [width (+ 2 chunk-size) ;(+ 2 (int (/ (count the-state) chunk-size)))\\n        base (- (int (/ width 2)) 1)\\n        the-range (range base\\n                    (count the-state) \\n                    (- width 2))\\n        new-range (->> the-range\\n                    (drop 1))\\n                    ;if none have 49 on or before the second to the last el on last set\\n                      ; add a new vec with the right stuff\\n                      ; else, if 49 comes before the second to the last el on last set\\n                      ; drop til zero\\n                      ; else, 0 is last?  good to go, rock on\\n                      ]\\n    (vec (pmap \#(wrap-sub the-state % width) \\n           the-range))))" "(count (chunkify2 nums 3))" "(chunkify2 nums 3)" "(count (chunkify2 nums 3))" "(/ 50.0 3)" "(chunkify2 nums 4)" "(count (chunkify2 nums 4))" "(/ 50.0 4)" "(int (/ 50 4))" "(int (/ 50 3))" "(if 0 true)" "(rem 50 3)" "(rem 50 4)" "(rem 50 5)" "(* 12 4)" "(* 16 3)" "(get-range 50 4)" "(get-range nums 4)" "(doc range)" "(range 50 48)" "(range 50 51)" "(range 50 53)" "(range 50 40)" "(range 50 40 -1)" "(wrap-sub nums 50 2)" "(wrap-sub nums 50 3)" "(wrap-sub nums 49 3)" "(rem 50 4)" "(range 50 (- 50 (rem 50 4)) -1)" "(range (- 50 1) (- (- 50 (rem 50 4)) 1) -1)" "(range (- 50 1) (- (- 50 (rem 50 5)) 1) -1)" "(range (- 50 1) (- (- 50 (rem 50 6)) 1) -1)" "(range (- 50 1) (- (- 50 (rem 50 7)) 1) -1)" "(range (- 50 1) (- (- 50 (rem 50 8)) 1) -1)" "(range (- 50 1) (- (- 50 (rem 50 9)) 1) -1)" "(defn range-tail [s c] (reverse (range (- size 1) (- (- size (rem size chunk-size)) 1) -1)))" "(defn range-tail [s c] (reverse (range (- s 1) (- (- s (rem s c)) 1) -1)))" "(range-tail 50 9)" "(range-tail 50 7)" "(range-tail 50 9)" "(wrap-sub nums 45 3)" "(defn range-tail [s c] (reverse (range (- s (rem s c)) s 1)))" "(range-tail 50 9)" "(range (- 50 1) (- (- 50 (rem 50 8)) 1) -1)" "(range (- 50 (rem 40 8)) 50)" "(rem 50 8)" "(range (- 50 (rem 50 8)) 50)" "(defn range-tail [s c] (range (- s (rem s c)) s 1))" "(range-tail 50 9)" "(defn range-tail [s c] (range (- s (rem s c)) s))" "(range-tail 50 9)" "(wrap-sub nums 47 5)" "(wrap-sub nums 47 7)" "(rem 50 9)" "(rem 50 4)" "(range-tail 50 4)" "(wrap-sub nums 48 2)" "(wrap-sub nums 48 3)" "(wrap-sub nums 48 4)" "(wrap-sub nums 49 4)" "(wrap-sub nums 49 8)" "(wrap-sub nums 49 4)" "(range-tail 50 9)" "(int (/ (count (range-tail 50 9)) 2))" "(inc (int (/ (count (range-tail 50 9)) 2)))" "(- 50 3)" "(int (/ 2 2))" "(inc (int (/ (count (range-tail 50 4)) 2)))" "(-50 2)" "(- 50 2)" "(int (/ (count (range-tail 50 9)) 2))" "(nth (int (/ (count (range-tail 50 9)) 2)) (range-tail 50 2))" "(nth (int (/ (count (range-tail 50 9)) 2)) (range-tail 50 9))" "(nth (range-tail 50 9) (int (/ (count (range-tail 50 9)) 2)))" "(nth (range-tail 50 4) (int (/ (count (range-tail 50 4)) 2)))" "(vec [] [])" "(vector [] [])" "(nth (range-tail 50 4) (int (/ (count (range-tail 50 4)) 2)))" "(wrap-sub nums 49 4)" "(wrap-sub nums 57 9)" "(wrap-sub nums 47 9)" "(defn tail-index [rt s] (nth rt (int (/ (count rt) 2))))" "(tail-index (range-tail 50 9) 5)" "(defn tail-index [rt] (nth rt (int (/ (count rt) 2))))" "(tail-index (range-tail 50 9) 5)" "(tail-index (range-tail 50 9))" "(tail-index (range-tail 50 6))" "(tail-index (range-tail 50 3))" "(tail-index (range-tail 50 4))" "(tail-index (range-tail 50 5))" "(tail-index (range-tail 50 6))" "(tail-index (range-tail 50 7))" "(tail-index (range-tail 50 8))" "(tail-index (range-tail 50 9))" "(tail-index (range-tail 50 10))" "(conj [[1][2]] [3])" "(defn chunkify2 [the-state chunk-size]\\n  (let [width (+ 2 chunk-size) ;(+ 2 (int (/ (count the-state) chunk-size)))\\n        size (count state)\\n        rem-size (rem size chunk-size)\\n        range-tail (range (- size rem-size) size)\\n        tail-size (+ 2 (count range-tail))\\n        tail-index (nth range-tail (int (/ (count range-tail) 2)))\\n        base (- (int (/ width 2)) 1)\\n        the-range (range base\\n                    (count the-state) \\n                    (- width 2))\\n        tail-sub (wrap-sub the-state tail-index tail-size)\\n                      ]\\n    (conj (vec (pmap \#(wrap-sub the-state % width) \\n           the-range)) tail-sub)))" "(chunkify2 nums 3)" "(chunkify2 nums 4)" "(chunkify2 nums 5)" "(chunkify2 nums 6)" "(chunkify2 nums 7)" "(chunkify2 nums 8)" "(chunkify2 nums 9)" "(defn chunkify2 [the-state chunk-size]\\n  (let [width (+ 2 chunk-size) ;(+ 2 (int (/ (count the-state) chunk-size)))\\n        the-range (range base\\n                    (count the-state) \\n                    (- width 2))\\n        size (count the-state)\\n        rem-size (rem size chunk-size)\\n        range-tail (range (- size rem-size) size)\\n        tail-size (+ 2 (count range-tail))\\n        tail-index (nth range-tail (int (/ (count range-tail) 2)))\\n        base (- (int (/ width 2)) 1)\\n        tail-sub (wrap-sub the-state tail-index tail-size)\\n                      ]\\n    (conj (vec (pmap \#(wrap-sub the-state % width) \\n           the-range)) tail-sub)))" "(defn chunkify2 [the-state chunk-size]\\n  (let [width (+ 2 chunk-size) ;(+ 2 (int (/ (count the-state) chunk-size)))\\n        base (- (int (/ width 2)) 1)\\n        the-range (range base\\n                    (count the-state) \\n                    (- width 2))\\n        size (count the-state)\\n        rem-size (rem size chunk-size)\\n        range-tail (range (- size rem-size) size)\\n        tail-size (+ 2 (count range-tail))\\n        tail-index (nth range-tail (int (/ (count range-tail) 2)))\\n        tail-sub (wrap-sub the-state tail-index tail-size)\\n                      ]\\n    (conj (vec (pmap \#(wrap-sub the-state % width) \\n           the-range)) tail-sub)))" "(chunkify2 nums 9)" "(/ 50 2)" "(/ 50 3)" "(- (/ 50 3) 1)" "(get-range 50 9)" "(get-range nums 9)" "(defn get-range2 [coll n] (range (- (int (/ (+ 2 n) 2)) 1) (count coll) (- (+ 2 n) 2)))" "(get-range2 nums 9)" "(defn get-range2 [coll n] (range (- (int (/ n 2)) 1) (count coll) (- n 2)))" "(get-range2 nums 9)" "(defn get-range2 [coll n] (range (- (int (/ (+ 2 n) 2)) 1) (count coll) (- n 2)))" "(get-range2 nums 9)" "(defn get-range2 [coll n] (range (- (int (/ n 2)) 1) (count coll) (- (+ 2 n) 2)))" "(get-range2 nums 9)" "(defn get-range2 [coll n] (range (- (int (/ (+ 2 n) 2)) 1) (* n (/ (count coll) 9)) (- (+ 2 n) 2)))" "(get-range2 nums 9)" "(* 9 (/ 50 9))" "(* 9 (int (/ 50 9)))" "(defn get-range2 [coll n] (range (- (int (/ (+ 2 n) 2)) 1) (* n (int (/ (count coll) 9))) (- (+ 2 n) 2)))" "(get-range2 nums 9)" "(get-range2 nums 4)" "(* (4 (int (/ 50 4))))" "(* 4 (int (/ 50 4)))" "(defn get-range2 [coll n] (range (- (int (/ (+ 2 n) 2)) 1) (* n (int (/ (count coll) n))) (- (+ 2 n) 2)))" "(get-range2 nums 4)" "(get-range2 nums 9)" "(defn chunkify2 [the-state chunk-size]\\n  (let [width (+ 2 chunk-size) ;(+ 2 (int (/ (count the-state) chunk-size)))\\n        base (- (int (/ width 2)) 1)\\n        the-range (range base\\n                    (* chunk-size (int (/ (count the-state) chunk-size)))\\n                    (- width 2))\\n        size (count the-state)\\n        rem-size (rem size chunk-size)\\n        range-tail (range (- size rem-size) size)\\n        tail-size (+ 2 (count range-tail))\\n        tail-index (nth range-tail (int (/ (count range-tail) 2)))\\n        tail-sub (wrap-sub the-state tail-index tail-size)\\n                      ]\\n    (conj (vec (pmap \#(wrap-sub the-state % width) \\n           the-range)) tail-sub)))" "(chunkify2 nums 9)" "(chunkify2 nums 4)" "(chunkify2 nums 3)" "(chunkify2 nums 5)" "(defn chunkify2 [the-state chunk-size]\\n  (let [width (+ 2 chunk-size) ;(+ 2 (int (/ (count the-state) chunk-size)))\\n        base (- (int (/ width 2)) 1)\\n        the-range (range base\\n                    (* chunk-size (int (/ (count the-state) chunk-size)))\\n                    (- width 2))\\n        size (count the-state)\\n        rem-size (rem size chunk-size)\\n        range-tail (vec (range (- size rem-size) size))\\n        tail-size (+ 2 (count range-tail))\\n        tail-index (nth range-tail (int (/ (count range-tail) 2)))\\n        tail-sub (wrap-sub the-state tail-index tail-size)\\n                      ]\\n    (conj (vec (pmap \#(wrap-sub the-state % width) \\n           the-range)) tail-sub)))" "(chunkify2 nums 3)" "(conj [[1] [2]] nil)" "(conj [[1] [2]] [])" "(defn chunkify2 [the-state chunk-size]\\n  (let [window (+ 2 chunk-size) ;(+ 2 (int (/ (count the-state) chunk-size)))\\n        first-index (- (int (/ window 2)) 1)\\n        the-range (range first-index\\n                    (* chunk-size (int (/ (count the-state) chunk-size)))\\n                    chunk-size)\\n        size (count the-state)\\n        rem-size (rem size chunk-size)\\n        tail-sub (if (not\= 0 rem-size)\\n                   (let [range-tail (vec (range (- size rem-size) size))\\n                         tail-size (+ 2 (count range-tail))\\n                         tail-index (nth range-tail (int (/ (count range-tail) 2)))]\\n                     (wrap-sub the-state tail-index tail-size)))]\\n    (if tail-sub\\n      (conj (vec (pmap \#(wrap-sub the-state % window) the-range)) \\n        tail-sub)\\n      (vec (pmap \#(wrap-sub the-state % window) the-range))))" "(defn chunkify2 [the-state chunk-size]\\n  (let [window (+ 2 chunk-size) ;(+ 2 (int (/ (count the-state) chunk-size)))\\n        first-index (- (int (/ window 2)) 1)\\n        the-range (range first-index\\n                    (* chunk-size (int (/ (count the-state) chunk-size)))\\n                    chunk-size)\\n        size (count the-state)\\n        rem-size (rem size chunk-size)\\n        tail-sub (if (not\= 0 rem-size)\\n                   (let [range-tail (vec (range (- size rem-size) size))\\n                         tail-size (+ 2 (count range-tail))\\n                         tail-index (nth range-tail (int (/ (count range-tail) 2)))]\\n                     (wrap-sub the-state tail-index tail-size)))]\\n    (if tail-sub\\n      (conj (vec (pmap \#(wrap-sub the-state % window) the-range)) \\n        tail-sub)\\n      (vec (pmap \#(wrap-sub the-state % window) the-range)))))" "(chunkify2 nums 5)" "(chunkify2 nums 2)" "(chunkify2 nums 3)" "(chunkify2 nums 4)" "(chunkify2 nums 5)" "(chunkify2 nums 6)" "(chunkify2 nums 7)" "(chunkify2 nums 8)" "(chunkify2 nums 9)" "(chunkify2 nums 10)" "(chunkify2 nums 19)" "(chunkify2 nums 24)" "(chunkify2 nums 25)" "(chunkify2 nums 26)" "(chunkify2 nums 40)" "(defn chunkify2 [the-state chunk-size]\\n  (let [window (+ 2 chunk-size)\\n        first-index (- (int (/ window 2)) 1)\\n        the-range (range first-index\\n                    (* chunk-size (int (/ (count the-state) chunk-size)))\\n                    chunk-size)\\n        size (count the-state)\\n        rem-size (rem size chunk-size)\\n        tail-sub (if (not\= 0 rem-size)\\n                   (let [range-tail (vec (range (- size rem-size) size))\\n                         tail-size (count range-tail)\\n                         tail-index (nth range-tail (int (/ tail-size 2)))]\\n                     (wrap-sub the-state tail-index (+ tail-size 2))))]\\n    (if tail-sub\\n      (conj (vec (pmap \#(wrap-sub the-state % window) the-range)) \\n        tail-sub)\\n      (vec (pmap \#(wrap-sub the-state % window) the-range)))))" "(chunkify2 nums 40)" "(def lnums (take 1021 (interate inc 0)))" "(def lnums (take 1021 (iterate inc 0)))" "lnums" "(chunkify2 lnums 40)" "(defn chunkify [the-state chunk-size]\\n  (let [window (+ 2 chunk-size)\\n        first-index (- (int (/ window 2)) 1)\\n        the-range (range first-index\\n                    (* chunk-size (int (/ (count the-state) chunk-size)))\\n                    chunk-size)\\n        size (count the-state)\\n        rem-size (rem size chunk-size)\\n        tail-sub (if (not\= 0 rem-size)\\n                   (let [range-tail (vec (range (- size rem-size) size))\\n                         tail-size (count range-tail)\\n                         tail-index (nth range-tail (int (/ tail-size 2)))]\\n                     (wrap-sub the-state tail-index (+ tail-size 2))))]\\n    (if tail-sub\\n      (conj (vec (pmap \#(wrap-sub the-state % window) the-range)) \\n        tail-sub)\\n      (vec (pmap \#(wrap-sub the-state % window) the-range)))))" "(defn run-chunks [the-stepper the-rule the-state chunk-size]\\n  (vec (drop 2 (flatten (pmap \#(the-stepper the-rule %) (chunkify the-state chunk-size))))))" "(defn chunkerator [the-steps the-stepper the-rule the-state chunk-size]\\n  (take the-steps (iterate \#(run-chunks the-stepper the-rule % chunk-size) the-state)))" "(def state (assoc (vec (take 1000000 (iterate identity 0))) 50000 1))" "(time (take 20 (drop 49990 (last (chunkerator 2 no-wrap-stepper-3 rule30 state 100)))))" "(time (take 20 (drop 49990 (last (run-steps 2 stepper-3 rule30 state)))))" "(time (take 20 (drop 49990 (last (chunkerator 2 no-wrap-stepper-3 rule30 state 10000)))))" "(time (take 20 (drop 49990 (last (run-steps 2 stepper-3 rule30 state)))))" "(time (take 20 (drop 49990 (last (chunkerator 2 no-wrap-stepper-3 rule30 state 10000)))))" "(defn chunkify [the-state chunk-size]\\n  (let [window (+ 2 chunk-size)\\n        first-index (- (int (/ window 2)) 1)\\n        the-range (range first-index\\n                    (* chunk-size (int (/ (count the-state) chunk-size)))\\n                    chunk-size)\\n        size (count the-state)\\n        rem-size (rem size chunk-size)\\n        tail-sub (if (not\= 0 rem-size)\\n                   (let [range-tail (vec (range (- size rem-size) size))\\n                         tail-size (count range-tail)\\n                         tail-index (nth range-tail (int (/ tail-size 2)))]\\n                     (wrap-sub the-state tail-index (+ tail-size 2))))]\\n    (if tail-sub\\n      (conj (vec (map \#(wrap-sub the-state % window) the-range)) \\n        tail-sub)\\n      (vec (map \#(wrap-sub the-state % window) the-range)))))" "(defn run-chunks [the-stepper the-rule the-state chunk-size]\\n  (vec (drop 2 (flatten (pmap \#(the-stepper the-rule %) (chunkify the-state chunk-size))))))" "(time (take 20 (drop 49990 (last (chunkerator 2 no-wrap-stepper-3 rule30 state 10000)))))" "(defn run-chunks [the-stepper the-rule the-state chunk-size]\\n  (vec (drop 2 (flatten (map \#(the-stepper the-rule %) (chunkify the-state chunk-size))))))" "(defn chunkify [the-state chunk-size]\\n  (let [window (+ 2 chunk-size)\\n        first-index (- (int (/ window 2)) 1)\\n        the-range (range first-index\\n                    (* chunk-size (int (/ (count the-state) chunk-size)))\\n                    chunk-size)\\n        size (count the-state)\\n        rem-size (rem size chunk-size)\\n        tail-sub (if (not\= 0 rem-size)\\n                   (let [range-tail (vec (range (- size rem-size) size))\\n                         tail-size (count range-tail)\\n                         tail-index (nth range-tail (int (/ tail-size 2)))]\\n                     (wrap-sub the-state tail-index (+ tail-size 2))))]\\n    (if tail-sub\\n      (conj (vec (pmap \#(wrap-sub the-state % window) the-range)) \\n        tail-sub)\\n      (vec (pmap \#(wrap-sub the-state % window) the-range)))))" "(time (take 20 (drop 49990 (last (chunkerator 2 no-wrap-stepper-3 rule30 state 10000)))))" "(defn run-chunks [the-stepper the-rule the-state chunk-size]\\n  (vec (drop 2 (flatten (pmap \#(the-stepper the-rule %) (chunkify the-state chunk-size))))))" "(time (take 20 (drop 49990 (last (chunkerator 2 no-wrap-stepper-3 rule30 state 10000)))))" "(time (take 20 (drop 49990 (last (chunkerator 3 no-wrap-stepper-3 rule30 state 10000)))))" "(time (take 20 (drop 49990 (last (run-steps 3 stepper-3 rule30 state)))))" "(time (take 20 (drop 49990 (last (chunkerator 4 no-wrap-stepper-3 rule30 state 10000)))))" "(time (take 20 (drop 49990 (last (run-steps 4 stepper-3 rule30 state)))))" "(time (take 20 (drop 49990 (last (chunkerator 10 no-wrap-stepper-3 rule30 state 10000)))))" "(time (take 20 (drop 49990 (last (run-steps 10 stepper-3 rule30 state)))))" "(time (take 20 (drop 49990 (last (chunkerator 10 no-wrap-stepper-3 rule30 state 100000)))))" "(time (take 20 (drop 49990 (last (run-steps 10 stepper-3 rule30 state)))))" "(time (take 20 (drop 49990 (last (chunkerator 10 no-wrap-stepper-3 rule30 state 1000)))))" "(ns automata.core)" "(def state (assoc (vec (take 20 (iterate identity 0))) 10 1))" "(defn mkrule [v1 v2 v3 v4 v5 v6 v7 v8]\\n  { [0 0 0] v1, [0 0 1] v2, [0 1 0] v3, [0 1 1] v4, [1 0 0] v5, [1 0 1] v6, [1 1 0] v7, [1 1 1] v8})" "(def rule30 (mkrule 0 1 1 1 1 0 0 0))" "(defn wrap-nth [the-state absolute-index relative-index]\\n  (let [size (count the-state)]\\n    (nth the-state\\n      (rem (+ absolute-index size relative-index) size))))" "(defn wrap-sub [the-state the-index the-width]\\n  (let [left-index (- (int (/ the-width 2)))\\n        right-index (+ the-width left-index)]\\n    (->> (range left-index right-index)\\n      (map \#(wrap-nth the-state the-index %) )\\n      (vec))))" "(defn stepper-3 [the-rule the-state]\\n  (->> (range (count the-state))\\n    (map \#(the-rule (wrap-sub the-state % 3)))\\n    (vec)))" "(defn run-steps [the-steps the-stepper the-rule the-state]\\n  (take the-steps (iterate \#(the-stepper the-rule %) the-state)))" "(defn chunk-stepper-3 [the-rule the-state]\\n  (->> (drop 1 (drop-last (range (count the-state))))\\n    (map \#(the-rule (wrap-sub the-state % 3)))\\n    (vec)))" "(defn chunkify [the-state chunk-size]\\n  (let [window (+ 2 chunk-size)\\n        first-index (- (int (/ window 2)) 1)\\n        the-range (range first-index\\n                    (* chunk-size (int (/ (count the-state) chunk-size)))\\n                    chunk-size)\\n        size (count the-state)\\n        rem-size (rem size chunk-size)\\n        tail-sub (if (not\= 0 rem-size)\\n                   (let [range-tail (vec (range (- size rem-size) size))\\n                         tail-size (count range-tail)\\n                         tail-index (nth range-tail (int (/ tail-size 2)))]\\n                     (wrap-sub the-state tail-index (+ tail-size 2))))]\\n    (if tail-sub\\n      (conj (vec (pmap \#(wrap-sub the-state % window) the-range)) \\n        tail-sub)\\n      (vec (pmap \#(wrap-sub the-state % window) the-range)))))" "(defn run-chunks [the-stepper the-rule the-state chunk-size]\\n  (vec (drop 2 (flatten (pmap \#(the-stepper the-rule %) (chunkify the-state chunk-size))))))" "(defn chunkerator [the-steps the-stepper the-rule the-state chunk-size]\\n  (take the-steps (iterate \#(run-chunks the-stepper the-rule % chunk-size) the-state)))" "(def state (assoc (vec (take 1000000 (iterate identity 0))) 50000 1))" "(time (take 20 (drop 49990 (last (run-steps 10 stepper-3 rule30 state)))))" "(time (take 20 (drop 49990 (last (chunkerator 10 chunk-stepper-3 rule30 state 1000)))))" "(time (take 20 (drop 49990 (last (run-steps 10 stepper-3 rule30 state)))))" "(time (take 20 (drop 49990 (last (run-chunks 10 chunk-stepper-3 rule30 state 1000)))))" "(defn chunkerator [the-stepper the-rule the-state chunk-size]\\n  (vec (drop 2 (flatten (pmap \#(the-stepper the-rule %) (chunkify the-state chunk-size))))))" "(defn run-chunks [the-steps the-stepper the-rule the-state chunk-size]\\n  (take the-steps (iterate \#(chunkerator the-stepper the-rule % chunk-size) the-state)))" "(time (take 20 (drop 49990 (last (run-chunks 10 chunk-stepper-3 rule30 state 1000)))))" "(def state (assoc (vec (take 20 (iterate identity 0))) 10 1))" "(run-chunks 10 chunk-stepper-3 rule30 state 3)" "(chunkerator chunk-stepper-3 rule30 state 3)" "(chunkerator chunk-stepper-3 rule30 *1 3)" "(defn chunkerator [the-stepper the-rule the-state chunk-size]\\n  (vec (flatten (pmap \#(the-stepper the-rule %) (chunkify the-state chunk-size)))))" "(chunkerator chunk-stepper-3 rule30 *1 3)" "(chunkerator chunk-stepper-3 rule30 state 3)" "(chunkerator chunk-stepper-3 rule30 *1 3)" "(defn chunkerator [the-stepper the-rule the-state chunk-size]\\n  (vec (flatten (pmap \#(the-stepper the-rule %) (chunkify the-state chunk-size)))))" "(run-chunks 10 chunk-stepper-3 rule30 state 3)" "(time (take 20 (drop 49990 (last (run-chunks 10 chunk-stepper-3 rule30 state 1000)))))" "(def state (assoc (vec (take 1000000 (iterate identity 0))) 50000 1))" "(time (take 20 (drop 49990 (last (run-chunks 10 chunk-stepper-3 rule30 state 1000)))))" "(defn chunkify [the-state chunk-size]\\n  (let [window (+ 2 chunk-size)\\n        first-index (- (int (/ window 2)) 1)\\n        the-range (vec (range first-index\\n                    (* chunk-size (int (/ (count the-state) chunk-size)))\\n                    chunk-size))\\n        size (count the-state)\\n        rem-size (rem size chunk-size)\\n        tail-sub (if (not\= 0 rem-size)\\n                   (let [range-tail (vec (range (- size rem-size) size))\\n                         tail-size (count range-tail)\\n                         tail-index (nth range-tail (int (/ tail-size 2)))]\\n                     (wrap-sub the-state tail-index (+ tail-size 2))))]\\n    (if tail-sub\\n      (conj (vec (pmap \#(wrap-sub the-state % window) the-range)) \\n        tail-sub)\\n      (vec (pmap \#(wrap-sub the-state % window) the-range)))))" "(defn wrap-sub [the-state the-index the-width]\\n  (let [left-index (- (int (/ the-width 2)))\\n        right-index (+ the-width left-index)]\\n    (->> (vec (range left-index right-index))\\n      (map \#(wrap-nth the-state the-index %) )\\n      (vec))))" "(defn stepper-3 [the-rule the-state]\\n  (->> (vec (range (count the-state)))\\n    (map \#(the-rule (wrap-sub the-state % 3)))\\n    (vec)))" "(defn chunk-stepper-3 [the-rule the-state]\\n  (->> (drop 1 (drop-last (vec (range (count the-state)))))\\n    (map \#(the-rule (wrap-sub the-state % 3)))\\n    (vec)))" "(defn chunkify [the-state chunk-size]\\n  (let [window (+ 2 chunk-size)\\n        first-index (- (int (/ window 2)) 1)\\n        the-range (vec (range first-index\\n                    (* chunk-size (int (/ (count the-state) chunk-size)))\\n                    chunk-size))\\n        size (count the-state)\\n        rem-size (rem size chunk-size)\\n        tail-sub (if (not\= 0 rem-size)\\n                   (let [range-tail (vec (range (- size rem-size) size))\\n                         tail-size (count range-tail)\\n                         tail-index (nth range-tail (int (/ tail-size 2)))]\\n                     (wrap-sub the-state tail-index (+ tail-size 2))))]\\n    (if tail-sub\\n      (conj (vec (pmap \#(wrap-sub the-state % window) the-range)) \\n        tail-sub)\\n      (vec (pmap \#(wrap-sub the-state % window) the-range)))))" "(defn chunkerator [the-stepper the-rule the-state chunk-size]\\n  (vec (flatten (pmap \#(the-stepper the-rule %) (chunkify the-state chunk-size)))))" "(defn run-chunks [the-steps the-stepper the-rule the-state chunk-size]\\n  (take the-steps (iterate \#(chunkerator the-stepper the-rule % chunk-size) the-state)))" "(time (take 20 (drop 49990 (last (run-chunks 10 chunk-stepper-3 rule30 state 1000)))))" "((((((((((((defn \u03BB\u262F\u262E[]\u03BB\u262F\u262E))))))))))))" "(defn wrap-sub [the-state the-index the-width]\\n  (let [left-index (- (int (/ the-width 2)))" "(defn wrap-sub [the-state the-index the-width]\\n  (let [left-index (- (int (/ the-width 2)))\\n        right-index (+ the-width left-index)\\n        size (count the-state)]\\n    (->> (vec (range left-index right-index))\\n      (map \#(nth the-state\\n              (rem (+ the-index size %) size))\\n      (vec)))))" "(time (take 20 (drop 49990 (last (run-chunks 10 chunk-stepper-3 rule30 state 1000)))))" "(time (take 20 (drop 49990 (last (run-steps 10 stepper-3 rule30 state)))))" "(defn wrap-sub [the-state the-index the-width]\\n  (let [left-index (- (int (/ the-width 2)))\\n        right-index (+ the-width left-index)\\n        size (count the-state)]\\n    (->> (vec (range left-index right-index))\\n      (map \#(nth the-state\\n              (rem (+ the-index size %) size)))\\n      (vec))))" "(time (take 20 (drop 49990 (last (run-chunks 10 chunk-stepper-3 rule30 state 1000)))))" "(* 16 16)" ";; Loading file src\\\\automata\\\\cljrule30.clj" "(clojure.lang.Compiler/load (java.io.StringReader. \\"(ns automata.cljrule30)\\\\n\\\\n(defn mkrule [v1 v2 v3 v4 v5 v6 v7 v8]\\\\n  {[1 1 1] v1\\\\n   [1 1 0] v2\\\\n   [1 0 1] v3\\\\n   [1 0 0] v4\\\\n   [0 1 1] v5\\\\n   [0 1 0] v6\\\\n   [0 0 1] v7\\\\n   [0 0 0] v8})\\\\n\\\\n(def rule30 (mkrule 0 0 0 1 1 1 1 0))\\\\n\\\\n(defn start-state [width]\\\\n  (-> (take width (repeat 0))\\\\n      vec\\\\n      (assoc (int (/ width 2)) 1)))\\\\n\\\\n(def state (start-state 20))\\\\n\\\\n(defn run-steps [the-steps the-stepper the-rule the-state]\\\\n  (take the-steps\\\\n        (iterate (partial the-stepper the-rule) the-state)))\\\\n\\\\n(defn cycle-partition [n step coll]\\\\n  (let [size (count coll)]\\\\n    (->> (cycle coll)\\\\n         (drop (- size step))\\\\n         (partition n step)\\\\n         (take size))))\\\\n\\\\n(assert (\= (cycle-partition 3 1 [0 1 2 3 4 5 6 7 8 9])\\\\n           [[9 0 1] [0 1 2] [1 2 3] [2 3 4] [3 4 5] [4 5 6] [5 6 7] [6 7 8] [7 8 9] [8 9 0]]  ))\\\\n\\\\n(defn stepper-3 [the-rule the-state]\\\\n  (->> the-state\\\\n       (cycle-partition 3 1)\\\\n       (map the-rule)\\\\n       vec))\\\\n\\\\n(defn run-automata [n-steps width]\\\\n  (run-steps n-steps  stepper-3 rule30 (start-state width)))\\\\n\\\\n(defn pp-automata [output]\\\\n  (let [to-pretty-char {0 \\\\\\" \\\\\\" 1 \\\\\\"\#\\\\\\"}]\\\\n    (doseq [line output]\\\\n      (println (apply str (map to-pretty-char line))))))\\\\n\\\\n(defn pfile-automata [output filename]\\\\n  (->> (with-out-str (pp-automata output))\\\\n       (spit filename)))\\\\n\\\\n(comment (pfile-automata (run-automata 150 300) \\\\\\"150x300.txt\\\\\\"))\\\\n\\") \\"C\:\\\\\\\\Users\\\\\\\\John\\\\\\\\workspace\\\\\\\\automata\\\\\\\\src\\\\\\\\automata\\\\\\\\cljrule30.clj\\" \\"C\:\\\\\\\\Users\\\\\\\\John\\\\\\\\workspace\\\\\\\\automata\\\\\\\\src\\")" "(pfile-automata (run-automata 150 300) \\"150x300.txt\\")" ";; Switching to automata.cljrule30 namespace" "(clojure.core/in-ns 'automata.cljrule30)" "(pfile-automata (run-automata 150 300) \\"150x300.txt\\")" ";; Loading file src\\\\automata\\\\pimage.clj" "(clojure.lang.Compiler/load (java.io.StringReader. \\"(ns automata.pimage)\\\\n\\\\n(ns automata.pimage\\\\n  (\:import (java.awt.image BufferedImage)\\\\n           (javax.imageio ImageIO)\\\\n           (java.io File)\\\\n           (java.awt Color))\\\\n  (\:require [automata.clj-rule30 \:as core]))\\\\n\\\\n(def *black-rgb* (.getRGB Color/BLACK))\\\\n(def *white-rgb* (.getRGB Color/WHITE)) \\\\n\\\\n\\\\n(defn rasterize\\\\n  \\\\\\"From [[0 1 0] [1 1 1] ...] to [[x y pixel] ...]\\\\\\"\\\\n  [steps width lines]\\\\n  (map (fn [[x y] pixel] [x y pixel])\\\\n       (for [y (range steps)\\\\n             x (range width)]\\\\n         [x y])\\\\n       (apply concat lines)))\\\\n\\\\n(assert (\= (rasterize 2 3 [[0 1 0] [1 1 1]])\\\\n           [[0 0 0] [1 0 1] [2 0 0]\\\\n            [0 1 1] [1 1 1] [2 1 1]]))\\\\n\\\\n\\\\n(defn create-image [steps width lines]\\\\n  (let [raster (rasterize steps width lines)\\\\n        img (BufferedImage. width steps BufferedImage/TYPE_INT_ARGB)]\\\\n    (doseq [[x y pixel] raster]\\\\n      (let [brush (if (\= pixel 1)\\\\n                    *black-rgb*\\\\n                    *white-rgb*)]\\\\n        (.setRGB img x y brush)))\\\\n    img))\\\\n\\\\n(defn pimg-automata [steps width]\\\\n  (let [lines (core/run-automata steps width)\\\\n        img (create-image steps width lines)]\\\\n    (ImageIO/write img \\\\\\"png\\\\\\" (File. (str steps \\\\\\"x\\\\\\" width \\\\\\".png\\\\\\")))))\\\\n\\\\n(comment\\\\n  (pimg-automata 30 60)\\\\n  )\\") \\"C\:\\\\\\\\Users\\\\\\\\John\\\\\\\\workspace\\\\\\\\automata\\\\\\\\src\\\\\\\\automata\\\\\\\\pimage.clj\\" \\"C\:\\\\\\\\Users\\\\\\\\John\\\\\\\\workspace\\\\\\\\automata\\\\\\\\src\\")" ";; Loading file src\\\\automata\\\\pimage.clj" "(clojure.lang.Compiler/load (java.io.StringReader. \\"(ns automata.pimage)\\\\n\\\\n(ns automata.pimage\\\\n  (\:import (java.awt.image BufferedImage)\\\\n           (javax.imageio ImageIO)\\\\n           (java.io File)\\\\n           (java.awt Color))\\\\n  (\:require [automata.clj-rule30 \:as core]))\\\\n\\\\n(def *black-rgb* (.getRGB Color/BLACK))\\\\n(def *white-rgb* (.getRGB Color/WHITE)) \\\\n\\\\n\\\\n(defn rasterize\\\\n  \\\\\\"From [[0 1 0] [1 1 1] ...] to [[x y pixel] ...]\\\\\\"\\\\n  [steps width lines]\\\\n  (map (fn [[x y] pixel] [x y pixel])\\\\n       (for [y (range steps)\\\\n             x (range width)]\\\\n         [x y])\\\\n       (apply concat lines)))\\\\n\\\\n(assert (\= (rasterize 2 3 [[0 1 0] [1 1 1]])\\\\n           [[0 0 0] [1 0 1] [2 0 0]\\\\n            [0 1 1] [1 1 1] [2 1 1]]))\\\\n\\\\n\\\\n(defn create-image [steps width lines]\\\\n  (let [raster (rasterize steps width lines)\\\\n        img (BufferedImage. width steps BufferedImage/TYPE_INT_ARGB)]\\\\n    (doseq [[x y pixel] raster]\\\\n      (let [brush (if (\= pixel 1)\\\\n                    *black-rgb*\\\\n                    *white-rgb*)]\\\\n        (.setRGB img x y brush)))\\\\n    img))\\\\n\\\\n(defn pimg-automata [steps width]\\\\n  (let [lines (core/run-automata steps width)\\\\n        img (create-image steps width lines)]\\\\n    (ImageIO/write img \\\\\\"png\\\\\\" (File. (str steps \\\\\\"x\\\\\\" width \\\\\\".png\\\\\\")))))\\\\n\\\\n(comment\\\\n  (pimg-automata 30 60)\\\\n  )\\") \\"C\:\\\\\\\\Users\\\\\\\\John\\\\\\\\workspace\\\\\\\\automata\\\\\\\\src\\\\\\\\automata\\\\\\\\pimage.clj\\" \\"C\:\\\\\\\\Users\\\\\\\\John\\\\\\\\workspace\\\\\\\\automata\\\\\\\\src\\")" "(ccw.debug.serverrepl/with-exception-serialization (clojure.core/binding [clojure.core/*compile-path* \\"classes\\"] (clojure.core/compile 'automata.cljrule30)))" "(ccw.debug.serverrepl/with-exception-serialization (clojure.core/binding [clojure.core/*compile-path* \\"classes\\"] (clojure.core/compile 'automata.pimage)))" ";; Switching to automata.pimage namespace" "(clojure.core/in-ns 'automata.pimage)" "(ccw.debug.serverrepl/with-exception-serialization (clojure.core/binding [clojure.core/*compile-path* \\"classes\\"] (clojure.core/compile 'automata.pimage)))" "(defn pimg-automata [steps width]\\n  (let [lines (core/run-automata steps width)\\n        img (create-image steps width lines)]\\n    (ImageIO/write img \\"png\\" (File. (str steps \\"x\\" width \\".png\\")))))" "(ns automata.pimage\\n  (\:import (java.awt.image BufferedImage)\\n           (javax.imageio ImageIO)\\n           (java.io File)\\n           (java.awt Color))\\n  (\:require [automata.clj-rule30 \:as core]))" "(ns automata.pimage\\n  (\:import (java.awt.image BufferedImage)\\n           (javax.imageio ImageIO)\\n           (java.io File)\\n           (java.awt Color))\\n  (\:require [automata.cljrule30 \:as core]))" ";; Loading file src\\\\automata\\\\pimage.clj" "(clojure.lang.Compiler/load (java.io.StringReader. \\"(ns automata.pimage)\\\\n\\\\n(ns automata.pimage\\\\n  (\:import (java.awt.image BufferedImage)\\\\n           (javax.imageio ImageIO)\\\\n           (java.io File)\\\\n           (java.awt Color))\\\\n  (\:require [automata.cljrule30 \:as core]))\\\\n\\\\n(def *black-rgb* (.getRGB Color/BLACK))\\\\n(def *white-rgb* (.getRGB Color/WHITE)) \\\\n\\\\n\\\\n(defn rasterize\\\\n  \\\\\\"From [[0 1 0] [1 1 1] ...] to [[x y pixel] ...]\\\\\\"\\\\n  [steps width lines]\\\\n  (map (fn [[x y] pixel] [x y pixel])\\\\n       (for [y (range steps)\\\\n             x (range width)]\\\\n         [x y])\\\\n       (apply concat lines)))\\\\n\\\\n(assert (\= (rasterize 2 3 [[0 1 0] [1 1 1]])\\\\n           [[0 0 0] [1 0 1] [2 0 0]\\\\n            [0 1 1] [1 1 1] [2 1 1]]))\\\\n\\\\n\\\\n(defn create-image [steps width lines]\\\\n  (let [raster (rasterize steps width lines)\\\\n        img (BufferedImage. width steps BufferedImage/TYPE_INT_ARGB)]\\\\n    (doseq [[x y pixel] raster]\\\\n      (let [brush (if (\= pixel 1)\\\\n                    *black-rgb*\\\\n                    *white-rgb*)]\\\\n        (.setRGB img x y brush)))\\\\n    img))\\\\n\\\\n(defn pimg-automata [steps width]\\\\n  (let [lines (core/run-automata steps width)\\\\n        img (create-image steps width lines)]\\\\n    (ImageIO/write img \\\\\\"png\\\\\\" (File. (str steps \\\\\\"x\\\\\\" width \\\\\\".png\\\\\\")))))\\\\n\\\\n(comment\\\\n  (pimg-automata 30 60)\\\\n  )\\") \\"C\:\\\\\\\\Users\\\\\\\\John\\\\\\\\workspace\\\\\\\\automata\\\\\\\\src\\\\\\\\automata\\\\\\\\pimage.clj\\" \\"C\:\\\\\\\\Users\\\\\\\\John\\\\\\\\workspace\\\\\\\\automata\\\\\\\\src\\")" "(pimg-automata 30 60)" "(pimg-automata 3000 6000)" "(pimg-automata 6000 1000)" ";; Switching to automata.cljrule30 namespace" "(clojure.core/in-ns 'automata.cljrule30)" "(run-automata 10 10)" ";; Switching to automata.cljrule30 namespace" "(clojure.core/in-ns 'automata.cljrule30)" ";; Switching to automata.cljrule30 namespace" "(run-automata 10 10)" "(run-automata 10 20)" "(time (take 10 (last (run-automata 10 20))))" "(time (take 10 (last (run-automata 10 10000))))" "(time (take 10 (last (run-automata 10 100000))))" "(time (take 10 (last (run-automata 10 1000000))))" "(clojure.core/in-ns 'automata.core)\\n(time (take 20 (drop 49990 (last (run-steps 10 stepper-3 rule30 state)))))\\n(clojure.core/in-ns 'automata.cljrule30)" "(doc wrap-sub)" ";; Switching to automata.core namespace" "(clojure.core/in-ns 'automata.core)" "(doc wrap-sub)" "(def state (assoc (vec (take 20 (iterate identity 0))) 10 1))" "(take 40 (iterate \#(wrap-sub % 5 3) state))" "(time (drop 40 (iterate \#(wrap-sub % 5 3) state)))" "(time (drop 4000 (iterate \#(wrap-sub % 5 3) state)))" "(time (drop 100000 (iterate \#(wrap-sub % 5 3) state)))" "(time (drop 1000000 (iterate \#(wrap-sub % 5 3) state)))" "(time (last (take 1000000 (iterate \#(wrap-sub % 5 3) state))))" "(time (last (take 1000 (iterate \#(wrap-sub % 5 3) state))))" "(time (last (take 10000 (iterate \#(wrap-sub % 5 3) state))))" "(time (last (take 100000 (iterate \#(wrap-sub % 5 3) state))))" "(stepper-3 rule30 state)" "(time (last (take 1000 (iterate \#(stepper-3 rule30 %) state))))" "(time (last (take 10000 (iterate \#(stepper-3 rule30 %) state))))" "(time (last (take 100000 (iterate \#(stepper-3 rule30 %) state))))" "(time (last (take 1000000 (iterate \#(stepper-3 rule30 %) state))))" ";; Switching to automata.cljrule30 namespace" "(clojure.core/in-ns 'automata.cljrule30)" "(time (last (take 1000000 (iterate \#(stepper-3 rule30 %) state))))" "\\"\\"" "(time (last (take 1000 (iterate \#(stepper-3 rule30 %) state))))" "(time (last (take 10000 (iterate \#(stepper-3 rule30 %) state))))" "(time (last (take 100000 (iterate \#(stepper-3 rule30 %) state))))" "(time (last (take 1000000 (iterate \#(stepper-3 rule30 %) state))))" "(time (last (run-automata 1000000 20)))" "(clojure.core/in-ns 'automata.core)\\n(def state (assoc (vec (take 1000000 (iterate identity 0))) 50000 1))\\n(clojure.core/in-ns 'automata.cljrule30)" "(def state (assoc (vec (take 1000000 (iterate identity 0))) 50000 1))" "(time (take 20 (drop 49990 (last (run-automata 10 1000000)))))" ";; Switching to automata.core namespace" "(clojure.core/in-ns 'automata.core)" "(time (take 20 (drop 49990 (last (run-steps 10 stepper-3 rule30 state)))))" "(time (last (take 10 (iterate \#(stepper-3 rule30 %) state))))" ";; Switching to automata.cljrule30 namespace" "(clojure.core/in-ns 'automata.cljrule30)" "(time (last (take 10 (iterate \#(stepper-3 rule30 %) state))))" "(count state)" "(defn nums [0 1 2 3 4 5 6 7 8 9])" "(def nums [0 1 2 3 4 5 6 7 8 9])" "(take 11 (cycle nums)" "(take 11 (cycle nums))" "(nth 1 (cycle nums))" "(nth (cycle nums) 1)" "(nth (cycle nums) -1)" "(last (cycle nums))" "(binding [*out* *err*] (if-not *e (println \\"No prior exception bound to *e.\\") (clojure.tools.nrepl/*print-error-detail* *e)))" "(def numbs [0 1 2 3 4 5 6 7 8 9])" ";; Switching to automata.cljrule30 namespace" "(clojure.core/in-ns 'automata.cljrule30)" "(cycle-partition 1 3 numbs)" ";; Loading file src\\\\automata\\\\cljrule30.clj" "(clojure.lang.Compiler/load (java.io.StringReader. \\"(ns automata.cljrule30)\\\\n\\\\n(defn mkrule [v1 v2 v3 v4 v5 v6 v7 v8]\\\\n  {[1 1 1] v1\\\\n   [1 1 0] v2\\\\n   [1 0 1] v3\\\\n   [1 0 0] v4\\\\n   [0 1 1] v5\\\\n   [0 1 0] v6\\\\n   [0 0 1] v7\\\\n   [0 0 0] v8})\\\\n\\\\n(def rule30 (mkrule 0 0 0 1 1 1 1 0))\\\\n\\\\n(defn start-state [width]\\\\n  (-> (take width (repeat 0))\\\\n      vec\\\\n      (assoc (int (/ width 2)) 1)))\\\\n\\\\n(def state (start-state 20))\\\\n\\\\n(defn run-steps [the-steps the-stepper the-rule the-state]\\\\n  (take the-steps\\\\n        (iterate (partial the-stepper the-rule) the-state)))\\\\n\\\\n(defn cycle-partition [n step coll]\\\\n  (let [size (count coll)]\\\\n    (->> (cycle coll)\\\\n         (drop (- size step))\\\\n         (partition n step)\\\\n         (take size))))\\\\n\\\\n(assert (\= (cycle-partition 3 1 [0 1 2 3 4 5 6 7 8 9])\\\\n           [[9 0 1] [0 1 2] [1 2 3] [2 3 4] [3 4 5] [4 5 6] [5 6 7] [6 7 8] [7 8 9] [8 9 0]]  ))\\\\n\\\\n(defn stepper-3 [the-rule the-state]\\\\n  (->> the-state\\\\n       (cycle-partition 3 1)\\\\n       (map the-rule)\\\\n       vec))\\\\n\\\\n(defn run-automata [n-steps width]\\\\n  (run-steps n-steps  stepper-3 rule30 (start-state width)))\\\\n\\\\n(defn pp-automata [output]\\\\n  (let [to-pretty-char {0 \\\\\\" \\\\\\" 1 \\\\\\"\#\\\\\\"}]\\\\n    (doseq [line output]\\\\n      (println (apply str (map to-pretty-char line))))))\\\\n\\\\n(defn pfile-automata [output filename]\\\\n  (->> (with-out-str (pp-automata output))\\\\n       (spit filename)))\\\\n\\\\n(def state (assoc (vec (take 1000000 (iterate identity 0))) 50000 1))\\\\n(comment (pfile-automata (run-automata 150 300) \\\\\\"150x300.txt\\\\\\"))\\\\n\\") \\"C\:\\\\\\\\Users\\\\\\\\John\\\\\\\\workspace\\\\\\\\automata\\\\\\\\src\\\\\\\\automata\\\\\\\\cljrule30.clj\\" \\"C\:\\\\\\\\Users\\\\\\\\John\\\\\\\\workspace\\\\\\\\automata\\\\\\\\src\\")" "(cycle-partition 1 3 numbs)" "(ccw.debug.serverrepl/with-exception-serialization (clojure.core/binding [clojure.core/*compile-path* \\"classes\\"] (clojure.core/compile 'automata.cljrule30)))" ";; Switching to automata.cljrule30 namespace" "(clojure.core/in-ns 'automata.cljrule30)" "(cycle-partition 1 3 numbs)" "(def nums [0 1 2 3 4 5 6 7 8 9])" "(cycle-partition 1 3 nums)" "(cycle-partition 3 1 nums)" "nums" "(def nums (take 1000 (iterate inc 0)))" "nums" "(cycle-partition 3 1 nums)" "(defn cycle-partition [n step coll]\\n  (let [size (count coll)]\\n    (->> (cycle coll)\\n         (drop (- size step))\\n         (partition n step)\\n         (take size)\\n         (vec))))" "(cycle-partition 3 1 nums)" "(defn cycle-partition [n step coll]\\n  (let [size (count coll)]\\n    (->> (cycle coll)\\n         (drop (- size step))\\n         (partition n step)\\n         (take size))))" "(cycle-partition 3 1 nums)" "(def nums1000 (take 1000 (iterate inc 0)))" "(def nums10000000 (take 10000000 (iterate inc 0)))" "(drop 999 nums1000)" "(drop 998 nums1000)" "(time (drop 998 nums1000))" "(time (drop 9999999 nums10000000))" "(time (drop 9999999 (cycle nums10000000)))" "(time (nth 9999999 (cycle nums10000000)))" "(time (nth (cycle nums10000000) 9999999))" "(time (nth (cycle nums1000) 999))" "(time (nth nums10000000 9999999))" "(time (nth (vec nums10000000) 9999999))" "(time (nth nums10000000 9999999))" "(time (drop 9999999 nums10000000))" "(time (last nums10000000))" "(type nums10000000)" "(time (last (vec nums10000000)))" "(def nums10000000 (vec (take 10000000 (iterate inc 0))))" "(def nums10000000 (take 10000000 (int [] (iterate inc 0))))" "(def nums10000000 (take 10000000 (into [] (iterate inc 0))))" "(nth 10 (iterate inc 0))" "(nth (iterate inc 0) 10)" "(nth (iterate inc 0) 10000000)" "(reduce identity (take 100 (iterate inc 0))" "(reduce identity (take 100 (iterate inc 0)))" "(reduce + (take 100 (iterate inc 0)))" "(reduce \= (take 100 (iterate inc 0)))" "(reduce second (take 100 (iterate inc 0)))" "(reduce \#(% %2) (take 100 (iterate inc 0)))" "(reduce (fn [] % %2) (take 100 (iterate inc 0)))" "(reduce (fn [x y] x y) (take 100 (iterate inc 0)))" "(reduce (fn [x y] x y) (take 1000000 (iterate inc 0)))" "(reduce (fn [x y] y) (take 1000000 (iterate inc 0)))" "(drop 1000000 (iterate inc 0))" "(def big (take 10000000 (iterate inc 0)))" "(count big)" "(first big)" "(last big)" "(nth big 2)" "(nth big 1000000)" "(nth big 10000)" "(nth big 100000)" "(def big (take 10000000 (iterate inc 0)))" "(nth big 100000)" "(def big (take 10 (iterate inc 10000000)))" "big" "(ccw.debug.serverrepl/with-exception-serialization (clojure.core/binding [clojure.core/*compile-path* \\"classes\\"] (clojure.core/compile 'automata.core)))" ";; Switching to automata.cljrule30 namespace" "(clojure.core/in-ns 'automata.cljrule30)" "(defn cycle-partition [n step coll]\\n  (let [size (count coll)]\\n    (->> (cycle coll)\\n         (drop (- size step))\\n         (partition n step)\\n         (take size))))" "(assert (\= (cycle-partition 3 1 [0 1 2 3 4 5 6 7 8 9])\\r\\n           [[9 0 1] [0 1 2] [1 2 3] [2 3 4] [3 4 5] [4 5 6] [5 6 7] [6 7 8] [7 8 9] [8 9 0]]  ))" "(def nums (take 20 (iterate inc 0)))" "nums" "(cycle-partition 3 1 nums)" "(cycle-partition 5 1 nums)" "(cycle-partition 5 2 nums)" "(cycle-partition 5 3 nums)" "(count nums)" "(defn chunk-cycle-partition [n step coll]\\n  (let [size (count coll)]\\n    (->> (cycle coll)\\n         (drop (- size step))\\n         (partition n step)\\n         (take size))))" "(defn chunk-cycle-partition [n step coll]\\n  (let [size (count coll)]\\n    (->> (cycle coll)\\n         (drop (- size 1))\\n         (partition n step)\\n         (take size))))" "(cycle-partition 5 3 nums)" "(chunk-cycle-partition 5 3 nums)" "(chunk-cycle-partition 9 7 nums)" "(chunk-cycle-partition 10 8 nums)" "(chunk-cycle-partition 8 6 nums)" "(apply + (map count (chunk-cycle-partition 8 6 nums)))" "(chunk-cycle-partition 8 6 nums)" "(defn chunk-cycle-partition [n step coll]\\n  (let [size (count coll)]\\n    (->> (cycle coll)\\n         (drop (- size 1))\\n         (partition n step)\\n         (take 4))))" "(chunk-cycle-partition 8 6 nums)" "(defn chunk-cycle-partition [n step coll]\\n  (let [size (count coll)\\n        rem-size (rem size n)\\n        take-size (int (/ size n))]\\n    (->> (cycle coll)\\n         (drop (- size 1))\\n         (partition n step)\\n         (take take-size)\\n         ;(if (not\= 0 rem-size))\\n           )))" "(chunk-cycle-partition 8 6 nums)" "(defn chunk-cycle-partition [n step coll]\\n  (let [size (count coll)\\n        _ (println size)\\n        rem-size (rem size n)\\n        _ (println rem-size)\\n        take-size (int (/ size n))\\n        _ (println take-size)]\\n    (->> (cycle coll)\\n         (drop (- size 1))\\n         (partition n step)\\n         (take take-size)\\n         ;(if (not\= 0 rem-size))\\n           )))" "(chunk-cycle-partition 8 6 nums)" "(defn chunk-cycle-partition [n step coll]\\n  (let [_ (println n \\" \\" step)\\n        size (count coll)\\n        _ (println size)\\n        rem-size (rem size n)\\n        _ (println rem-size)\\n        take-size (int (/ size n))\\n        _ (println take-size)]\\n    (->> (cycle coll)\\n         (drop (- size 1))\\n         (partition n step)\\n         (take take-size)\\n         ;(if (not\= 0 rem-size))\\n           )))" "(chunk-cycle-partition 8 6 nums)" "(rem 20 6)" "(rem 6 20)" "(chunk-cycle-partition 8 6 nums)" "(int (/ 20 8))" "(int (/ 20 6))" "(defn chunk-cycle-partition [n step coll]\\n  (let [_ (println n \\" \\" step)\\n        size (count coll)\\n        _ (println size)\\n        rem-size (rem size n)\\n        _ (println rem-size)\\n        take-size (int (/ size step))\\n        _ (println take-size)]\\n    (->> (cycle coll)\\n         (drop (- size 1))\\n         (partition n step)\\n         (take take-size)\\n         ;(if (not\= 0 rem-size))\\n           )))" "(chunk-cycle-partition 8 6 nums)" "(defn chunk-cycle-partition [n step coll]\\n  (let [_ (println n \\" \\" step)\\n        size (count coll)\\n        _ (println size)\\n        rem-size (rem size n)\\n        _ (println rem-size)\\n        take-size (int (/ size step))\\n        _ (println take-size)\\n        _ (println (drop (* step take-size) coll)]\\n    (->> (cycle coll)\\n         (drop (- size 1))\\n         (partition n step)\\n         (take take-size)\\n         (fn [x]\\n           (if (not\= 0 rem-size)\\n             (conj x (drop (* step take-size) coll))\\n             x))\\n           )))" "(defn chunk-cycle-partition [n step coll]\\n  (let [_ (println n \\" \\" step)\\n        size (count coll)\\n        _ (println size)\\n        rem-size (rem size n)\\n        _ (println rem-size)\\n        take-size (int (/ size step))\\n        _ (println take-size)\\n        _ (println (drop (* step take-size) coll))]\\n    (->> (cycle coll)\\n         (drop (- size 1))\\n         (partition n step)\\n         (take take-size)\\n         (fn [x]\\n           (if (not\= 0 rem-size)\\n             (conj x (drop (* step take-size) coll))\\n             x))\\n           )))" "(chunk-cycle-partition 8 6 nums)" "(defn chunk-cycle-partition [n step coll]\\n  (let [_ (println n \\" \\" step)\\n        size (count coll)\\n        _ (println size)\\n        rem-size (rem size n)\\n        _ (println rem-size)\\n        take-size (int (/ size step))\\n        _ (println take-size)\\n        _ (println (drop (* step take-size) coll))\\n        tail-if (fn [x]\\n                  (if (not\= 0 rem-size)\\n                    (conj x (drop (* step take-size) coll))\\n                    x))\\n        ]\\n    (->> (cycle coll)\\n         (drop (- size 1))\\n         (partition n step)\\n         (take take-size)\\n         (tail-if)\\n           )))" "(chunk-cycle-partition 8 6 nums)" "(defn chunk-cycle-partition [n step coll]\\n  (let [_ (println n \\" \\" step)\\n        size (count coll)\\n        _ (println size)\\n        rem-size (rem size n)\\n        _ (println rem-size)\\n        take-size (int (/ size step))\\n        _ (println take-size)\\n        _ (println (drop (* step take-size) coll))\\n        tail-if (fn [x]\\n                  (if (not\= 0 rem-size)\\n                    (cons x (drop (* step take-size) coll))\\n                    x))\\n        ]\\n    (->> (cycle coll)\\n         (drop (- size 1))\\n         (partition n step)\\n         (take take-size)\\n         (tail-if)\\n           )))" "(chunk-cycle-partition 8 6 nums)" "(defn chunk-cycle-partition [n step coll]\\n  (let [_ (println n \\" \\" step)\\n        size (count coll)\\n        _ (println size)\\n        rem-size (rem size n)\\n        _ (println rem-size)\\n        take-size (int (/ size step))\\n        _ (println take-size)\\n        _ (println (drop (* step take-size) coll))\\n        tail-if (fn [x]\\n                  (if (not\= 0 rem-size)\\n                    (conj (vec x) (drop (* step take-size) coll))\\n                    x))\\n        ]\\n    (->> (cycle coll)\\n         (drop (- size 1))\\n         (partition n step)\\n         (take take-size)\\n         (tail-if)\\n           )))" "(chunk-cycle-partition 8 6 nums)" "*1" "(map vec *1)" "(conj [] 1 2 4)" "(defn chunk-cycle-partition [n step coll]\\n  (let [_ (println n \\" \\" step)\\n        size (count coll)\\n        _ (println size)\\n        rem-size (rem size n)\\n        _ (println rem-size)\\n        take-size (int (/ size step))\\n        _ (println take-size)\\n        _ (println (drop (* step take-size) coll))\\n        tail-if (fn [x]\\n                  (if (not\= 0 rem-size)\\n                    (conj x (drop (* step take-size) coll) (nth coll 0))\\n                    x))\\n        ]\\n    (->> (cycle coll)\\n         (drop (- size 1))\\n         (partition n step)\\n         (take take-size)\\n         (map vec)\\n         (vec)\\n         (tail-if)\\n           )))" "(chunk-cycle-partition 8 6 nums)" "(defn chunk-cycle-partition [n step coll]\\n  (let [_ (println n \\" \\" step)\\n        size (count coll)\\n        _ (println size)\\n        rem-size (rem size n)\\n        _ (println rem-size)\\n        take-size (int (/ size step))\\n        _ (println take-size)\\n        _ (println (drop (* step take-size) coll))\\n        tail-if (fn [x]\\n                  (if (not\= 0 rem-size)\\n                    (conj x \\n                      (conj (vec (drop (* step take-size) coll)) (nth coll 0)))\\n                    x))\\n        ]\\n    (->> (cycle coll)\\n         (drop (- size 1))\\n         (partition n step)\\n         (take take-size)\\n         (map vec)\\n         (vec)\\n         (tail-if)\\n           )))" "(chunk-cycle-partition 8 6 nums)" "(defn chunk-cycle-partition [n step coll]\\n  (let [_ (println n \\" \\" step)\\n        size (count coll)\\n        _ (println size)\\n        rem-size (rem size n)\\n        _ (println rem-size)\\n        take-size (int (/ size step))\\n        _ (println take-size)\\n        _ (println (drop (* step take-size) coll))\\n        tail-if (fn [x]\\n                  (if (not\= 0 rem-size)\\n                    (conj x \\n                      (conj (vec (drop (- (* step take-size) 1) coll)) (nth coll 0)))\\n                    x))\\n        ]\\n    (->> (cycle coll)\\n         (drop (- size 1))\\n         (partition n step)\\n         (take take-size)\\n         (map vec)\\n         (vec)\\n         (tail-if)\\n           )))" "(chunk-cycle-partition 8 6 nums)" "(chunk-cycle-partition 5 3 nums)" "(defn chunk-cycle-partition [n step coll]\\n  (let [_ (println n \\" \\" step)\\n        size (count coll)\\n        _ (println size)\\n        rem-size (rem size step)\\n        _ (println rem-size)\\n        take-size (int (/ size step))\\n        _ (println take-size)\\n        _ (println (drop (* step take-size) coll))\\n        tail-if (fn [x]\\n                  (if (not\= 0 rem-size)\\n                    (conj x \\n                      (conj (vec (drop (- (* step take-size) 1) coll)) (nth coll 0)))\\n                    x))\\n        ]\\n    (->> (cycle coll)\\n         (drop (- size 1))\\n         (partition n step)\\n         (take take-size)\\n         (map vec)\\n         (vec)\\n         (tail-if)\\n           )))" "(chunk-cycle-partition 5 3 nums)" "(chunk-cycle-partition 8 6 nums)" "(chunk-cycle-partition 4 2 nums)" "(chunk-cycle-partition 5 3 nums)" "(chunk-cycle-partition 6 4 nums)" "(chunk-cycle-partition 12 10 nums)" "(chunk-cycle-partition 17 15 nums)" "(defn chunk-cycle-partition [step coll]\\n  (let [n (+ step 2)\\n        _ (println n \\" \\" step)\\n        size (count coll)\\n        _ (println size)\\n        rem-size (rem size step)\\n        _ (println rem-size)\\n        take-size (int (/ size step))\\n        _ (println take-size)\\n        _ (println (drop (* step take-size) coll))\\n        tail-if (fn [x]\\n                  (if (not\= 0 rem-size)\\n                    (conj x \\n                      (conj (vec (drop (- (* step take-size) 1) coll)) (nth coll 0)))\\n                    x))\\n        ]\\n    (->> (cycle coll)\\n         (drop (- size 1))\\n         (partition n step)\\n         (take take-size)\\n         (map vec)\\n         (vec)\\n         (tail-if)\\n           )))" "(chunk-cycle-partition 17 15 nums)" "(chunk-cycle-partition 15 nums)" "(chunk-cycle-partition 3 nums)" "(defn chunk-cycle-partition [coll step]\\n  (let [n (+ step 2)\\n        _ (println n \\" \\" step)\\n        size (count coll)\\n        _ (println size)\\n        rem-size (rem size step)\\n        _ (println rem-size)\\n        take-size (int (/ size step))\\n        _ (println take-size)\\n        _ (println (drop (* step take-size) coll))\\n        tail-if (fn [x]\\n                  (if (not\= 0 rem-size)\\n                    (conj x \\n                      (conj (vec (drop (- (* step take-size) 1) coll)) (nth coll 0)))\\n                    x))\\n        ]\\n    (->> (cycle coll)\\n         (drop (- size 1))\\n         (partition n step)\\n         (take take-size)\\n         (map vec)\\n         (vec)\\n         (tail-if)\\n           )))" "(chunk-cycle-partition nums 3)" "(defn chunk-cycle-partition [step coll]\\n  (let [n (+ step 2)\\n        _ (println n \\" \\" step)\\n        size (count coll)\\n        _ (println size)\\n        rem-size (rem size step)\\n        _ (println rem-size)\\n        take-size (int (/ size step))\\n        _ (println take-size)\\n        _ (println (drop (* step take-size) coll))\\n        tail-if (fn [x]\\n                  (if (not\= 0 rem-size)\\n                    (conj x \\n                      (conj (vec (drop (- (* step take-size) 1) coll)) (nth coll 0)))\\n                    x))\\n        ]\\n    (->> (cycle coll)\\n         (drop (- size 1))\\n         (partition n step)\\n         (take take-size)\\n         (map vec)\\n         (vec)\\n         (tail-if)\\n           )))" "(chunk-cycle-partition 3 nums)" "(chunk-cycle-partition 4 nums)" "(drop 2 [0 1 2 3 4])" "(doc subvec)" "(defn chunk-cycle-partition [step coll]\\n  (let [n (+ step 2)\\n        size (count coll)\\n        rem-size (rem size step)\\n        take-size (int (/ size step))\\n        append-remaining\\n          \#(if (not\= 0 rem-size)\\n             (conj % \\n               (conj (vec (drop (- (* step take-size) 1) coll)) \\n                 (nth coll 0)))\\n             %)]\\n    (->> (cycle coll)\\n         (drop (- size 1))\\n         (partition n step)\\n         (take take-size)\\n         (map vec)\\n         (vec)\\n         (tail-if)\\n           )))" "(defn chunk-cycle-partition [step coll]\\n  (let [n (+ step 2)\\n        size (count coll)\\n        rem-size (rem size step)\\n        take-size (int (/ size step))\\n        append-remaining\\n          \#(if (not\= 0 rem-size)\\n             (conj % \\n               (conj (vec (drop (- (* step take-size) 1) coll)) \\n                 (nth coll 0)))\\n             %)]\\n    (->> (cycle coll)\\n         (drop (- size 1))\\n         (partition n step)\\n         (take take-size)\\n         (map vec)\\n         (vec)\\n         (append-remaining)\\n           )))" "(chunk-cycle-partition 4 nums)" "nums" "(subvec nums 1 2)" "(subvec (vec nums) 1 2)" "(subvec (vec nums) 4 2)" "(subvec (vec nums) 4 -2)" "(subvec (vec nums) -4 2)" "(doc subvec)" "(subvec (vec nums) 18)" "(subvec (cycle (vec nums)) 18 20)" "(subvec (vec (cycle nums)) 18 20)" "(subvec (vec nums) 18)" "(defn chunk-cycle-partition [step coll]\\n  (let [n (+ step 2)\\n        size (count coll)\\n        rem-size (rem size step)\\n        take-size (int (/ size step))\\n        append-remaining\\n          \#(if (not\= 0 rem-size)\\n             (conj % \\n               (conj (vec (drop (- (* step take-size) 1) coll))\\n                 (nth coll 0)))\\n             %)]\\n    (->> (cycle coll)\\n         (drop (- size 1))\\n         (partition (+ step 2) step)\\n         (take take-size)\\n         (map vec)\\n         (vec)\\n         (append-remaining)\\n           )))" "(clojure.core/in-ns 'automata.cljrule30)\\n(defn chunk-cycle-partition [step coll]\\n  (let [n (+ step 2)\\n        size (count coll)\\n        rem-size (rem size step)\\n        take-size (int (/ size step))\\n        append-remaining\\n          \#(if (not\= 0 rem-size)\\n             (conj % \\n               (conj (vec (drop (- (* step take-size) 1) coll))\\n                 (nth coll 0)))\\n             %)]\\n    (->> (cycle coll)\\n         (drop (- size 1))\\n         (partition (+ step 2) step)\\n         (take take-size)\\n         (map vec)\\n         (vec)\\n         (append-remaining)\\n           )))\\n(clojure.core/in-ns 'user)" ";; Switching to automata.cljrule30 namespace" "(clojure.core/in-ns 'automata.cljrule30)" "nums" "(defn nums (take 20 (iterate inc 0)))" "(def nums (take 20 (iterate inc 0)))" "nums" "(chunk-cycle-partition 3 nums)" "(defn chunk-cycle-partition [step coll]\\n  (let [size (count coll)\\n        take-size (int (/ size step))\\n        append-remaining\\n          \#(if (not\= 0 (rem size step))\\n             (->> (nth coll 0)\\n                  (conj (vec (drop (- (* step take-size)  1) coll)))\\n                  (conj %))\\n             %)]\\n    (->> (cycle coll)\\n         (drop (- size 1))\\n         (partition (+ step 2) step)\\n         (take take-size)\\n         (map vec)\\n         (vec)\\n         (append-remaining))))" "(chunk-cycle-partition 3 nums)" "(chunk-cycle-partition 6 nums)" ";; Switching to automata.par namespace" "(clojure.core/in-ns 'automata.par)" ";; Switching to automata.par namespace" "(clojure.core/in-ns 'automata.par)" "(time (take 20 \\n        (drop 49990 \\n          (last (run-chunks 10 chunk-stepper-3 rule30 state 1000)))))" ";; Loading file src\\\\automata\\\\par.clj" "(clojure.lang.Compiler/load (java.io.StringReader. \\"(ns automata.par)\\\\n\\\\n(defn chunk-stepper-3 [the-rule]\\\\n  (fn [the-state]\\\\n    (->> (drop 1 (drop-last (vec (range (count the-state)))))\\\\n         (map \#(the-rule (core/wrap-sub the-state % 3)))\\\\n         (vec))))\\\\n\\\\n(defn chunkify [the-state chunk-size]\\\\n  (let [window (+ 2 chunk-size)\\\\n        first-index (- (int (/ window 2)) 1)\\\\n        the-range (vec (range first-index\\\\n                    (* chunk-size (int (/ (count the-state) chunk-size)))\\\\n                    chunk-size))\\\\n        size (count the-state)\\\\n        rem-size (rem size chunk-size)\\\\n        tail-sub (if (not\= 0 rem-size)\\\\n                   (let [range-tail (vec (range (- size rem-size) size))\\\\n                         tail-size (count range-tail)\\\\n                         tail-index (nth range-tail (int (/ tail-size 2)))]\\\\n                     (wrap-sub the-state tail-index (+ tail-size 2))))]\\\\n    (if tail-sub\\\\n      (conj (vec (pmap \#(wrap-sub the-state % window) the-range)) \\\\n        tail-sub)\\\\n      (vec (pmap \#(wrap-sub the-state % window) the-range)))))\\\\n\\\\n(defn chunk-cycle-partition [step coll]\\\\n  (let [size (count coll)\\\\n        take-size (int (/ size step))\\\\n        append-remaining\\\\n          \#(if (not\= 0 (rem size step))\\\\n             (->> (nth coll 0)\\\\n                  (conj (vec (drop (- (* step take-size)  1) coll)))\\\\n                  (conj %))\\\\n             %)]\\\\n    (->> (cycle coll)\\\\n         (drop (- size 1))\\\\n         (partition (+ step 2) step)\\\\n         (take take-size)\\\\n         (map vec)\\\\n         (vec)\\\\n         (append-remaining))))\\\\n\\\\n;; Chunks and un-chunks using the stepper\\\\n(defn chunkerator [the-stepper the-rule the-state chunk-size]\\\\n  (vec (flatten (pmap \#(the-stepper the-rule %) \\\\n                  (chunk-cycle-partition chunk-size the-state)))))\\\\n\\\\n;; iterates the chunkerator\\\\n(defn run-chunks [the-steps the-stepper the-rule the-state chunk-size]\\\\n  (take the-steps \\\\n    (iterate \#(chunkerator the-stepper the-rule % chunk-size) the-state)))\\\\n\\\\n;(comment\\\\n(def initial-conditions (start-state 100000))\\\\n(time (take 20 \\\\n        (drop 49990 \\\\n          (last (run-chunks 10 chunk-stepper-3 rule30 state 1000)))))\\\\n;)\\\\n\\") \\"C\:\\\\\\\\Users\\\\\\\\John\\\\\\\\workspace\\\\\\\\automata\\\\\\\\src\\\\\\\\automata\\\\\\\\par.clj\\" \\"C\:\\\\\\\\Users\\\\\\\\John\\\\\\\\workspace\\\\\\\\automata\\\\\\\\src\\")" "(ns automata.par\\n  (\:require [automata.core \:as core]\\n            [automata.rule30 \:as rule30]))" "(clojure.core/in-ns 'automata.rule30)\\n(ns automata.rule30\\n  (\:require [automata.core as\: core]))\\n(clojure.core/in-ns 'automata.par)" "(ns automata.rule30\\n  (\:require [automata.core as\: core]))" "(clojure.core/in-ns 'automata.rule30)\\n(ns automata.rule30\\n  (\:require [automata.core as\: core]))\\n(clojure.core/in-ns 'automata.par)" "(clojure.core/in-ns 'automata.rule30)\\n(def rule30 (mkrule 0 0 0 1 1 1 1 0))\\n(clojure.core/in-ns 'automata.par)" "(clojure.core/in-ns 'automata.rule30)\\n(ns automata.rule30\\n  (\:require [automata.core as\: core]))\\n(clojure.core/in-ns 'automata.par)" "(clojure.core/in-ns 'automata.rule30)\\n(ns automata.rule30\\n  (\:require [automata.core \:as core]))\\n(clojure.core/in-ns 'automata.par)" ";; Loading file src\\\\automata\\\\rule30.clj" "(clojure.lang.Compiler/load (java.io.StringReader. \\"(ns automata.rule30\\\\n  (\:require [automata.core \:as core]))\\\\n\\\\n(def rule30 (mkrule 0 0 0 1 1 1 1 0))\\\\n\\\\n(def rule-30-stepper\\\\n  (make-stepper rule30))\\\\n\\\\n\\\\n(comment\\\\n  (def initial-conditions (start-state 100000))\\\\n  (time (take 20 (drop 49990 (last (run-steps 10 rule-30-stepper initial-conditions)))))\\\\n)\\\\n\\") \\"C\:\\\\\\\\Users\\\\\\\\John\\\\\\\\workspace\\\\\\\\automata\\\\\\\\src\\\\\\\\automata\\\\\\\\rule30.clj\\" \\"C\:\\\\\\\\Users\\\\\\\\John\\\\\\\\workspace\\\\\\\\automata\\\\\\\\src\\")" "(clojure.core/in-ns 'automata.rule30)\\n(def rule30 (core/mkrule 0 0 0 1 1 1 1 0))\\n(clojure.core/in-ns 'automata.par)" "(clojure.core/in-ns 'automata.rule30)\\n(def rule30 (core/make-rule 0 0 0 1 1 1 1 0))\\n(clojure.core/in-ns 'automata.par)" "(clojure.core/in-ns 'automata.rule30)\\n(def rule-30-stepper\\n  (make-stepper rule30))\\n(clojure.core/in-ns 'automata.par)" ";; Loading file src\\\\automata\\\\core.clj" "(clojure.lang.Compiler/load (java.io.StringReader. \\"(ns automata.core)\\\\n\\\\n(defn make-initial-conditions [width]\\\\n  (-> (take width (repeat 0))\\\\n      vec\\\\n      (assoc (int (/ width 2)) 1)))\\\\n\\\\n(defn make-rule [v1 v2 v3 v4 v5 v6 v7 v8]\\\\n  { [1 1 1] v1\\\\n    [1 1 0] v2\\\\n    [1 0 1] v3\\\\n    [1 0 0] v4\\\\n    [0 1 1] v5\\\\n    [0 1 0] v6\\\\n    [0 0 1] v7\\\\n    [0 0 0] v8 })\\\\n\\\\n(defn wrap-sub [the-state the-index the-width]\\\\n  (let [left-index (- (int (/ the-width 2)))\\\\n        right-index (+ the-width left-index)\\\\n        size (count the-state)]\\\\n    (->> (vec (range left-index right-index))\\\\n         (map \#(nth the-state\\\\n              (rem (+ the-index size %) size)))\\\\n         (vec))))\\\\n\\\\n(defn make-stepper [the-rule]\\\\n  (fn [the-state] \\\\n    (->> (vec (range (count the-state)))\\\\n         (map \#(the-rule (wrap-sub the-state % 3)))\\\\n         (vec))))\\\\n\\\\n(defn run-steps [the-steps the-stepper the-state]\\\\n  (take the-steps (iterate (partial the-stepper) the-state)))\\\\n\\") \\"C\:\\\\\\\\Users\\\\\\\\John\\\\\\\\workspace\\\\\\\\automata\\\\\\\\src\\\\\\\\automata\\\\\\\\core.clj\\" \\"C\:\\\\\\\\Users\\\\\\\\John\\\\\\\\workspace\\\\\\\\automata\\\\\\\\src\\")" "(clojure.core/in-ns 'automata.rule30)\\n(def rule-30-stepper\\n  (make-stepper rule30))\\n(clojure.core/in-ns 'automata.par)" "(clojure.core/in-ns 'automata.core)\\n(defn make-stepper [the-rule]\\n  (fn [the-state] \\n    (->> (vec (range (count the-state)))\\n         (map \#(the-rule (wrap-sub the-state % 3)))\\n         (vec))))\\n(clojure.core/in-ns 'automata.par)" "(clojure.core/in-ns 'automata.rule30)\\n(def rule-30-stepper\\n  (make-stepper rule30))\\n(clojure.core/in-ns 'automata.par)" "(clojure.core/in-ns 'automata.rule30)\\n(def rule-30-stepper\\n  (core/make-stepper rule30))\\n(clojure.core/in-ns 'automata.par)" "(ns automata.par\\n  (\:require [automata.core \:as core]\\n            [automata.rule30 \:as rule30]))" "(def initial-conditions (start-state 100000))" "(def initial-conditions (core/make-initial-conditions 100000))" "(time (take 20 \\n        (drop 49990 \\n          (last (run-chunks 10 chunk-stepper-3 rule30 state 1000)))))" "(defn run-chunks [the-steps the-stepper the-rule the-state chunk-size]\\n  (take the-steps \\n    (iterate \#(chunkerator the-stepper the-rule % chunk-size) the-state)))" "(defn chunkerator [the-stepper the-rule the-state chunk-size]\\n  (vec (flatten (pmap \#(the-stepper the-rule %) \\n                  (chunk-cycle-partition chunk-size the-state)))))" "(defn chunk-cycle-partition [step coll]\\n  (let [size (count coll)\\n        take-size (int (/ size step))\\n        append-remaining\\n          \#(if (not\= 0 (rem size step))\\n             (->> (nth coll 0)\\n                  (conj (vec (drop (- (* step take-size)  1) coll)))\\n                  (conj %))\\n             %)]\\n    (->> (cycle coll)\\n         (drop (- size 1))\\n         (partition (+ step 2) step)\\n         (take take-size)\\n         (map vec)\\n         (vec)\\n         (append-remaining))))" "(defn chunkerator [the-stepper the-rule the-state chunk-size]\\n  (vec (flatten (pmap \#(the-stepper the-rule %) \\n                  (chunk-cycle-partition chunk-size the-state)))))" "(defn run-chunks [the-steps the-stepper the-rule the-state chunk-size]\\n  (take the-steps \\n    (iterate \#(chunkerator the-stepper the-rule % chunk-size) the-state)))" "(time (take 20 \\n        (drop 49990 \\n          (last (run-chunks 10 chunk-stepper-3 rule30 state 1000)))))" "(time (take 20 \\n        (drop 49990 \\n          (last (run-chunks 10 chunk-stepper-3 rule30/rule30 state 1000)))))" "(time (take 20 \\n        (drop 49990 \\n          (last \\n            (run-chunks 10 \\n              chunk-stepper-3 rule30/rule30 initial-conditions 1000)))))" "(defn chunk-stepper-3 [the-rule]\\n  (fn [the-state]\\n    (->> (drop 1 (drop-last (vec (range (count the-state)))))\\n         (map \#(the-rule (core/wrap-sub the-state % 3)))\\n         (vec))))" "(time (take 20 \\n        (drop 49990 \\n          (last \\n            (run-chunks 10 \\n              chunk-stepper-3 rule30/rule30 initial-conditions 1000)))))" "(defn make-chunk-stepper [the-rule]\\n  (fn [the-state]\\n    (->> (drop 1 (drop-last (vec (range (count the-state)))))\\n         (map \#(the-rule (core/wrap-sub the-state % 3)))\\n         (vec))))" "(def rule30-chunk-stepper\\n  (make-chunk-stepper rule30/rule30))" "(defn chunkerator [the-stepper the-state chunk-size]\\n  (vec (flatten (pmap \#(the-stepper %) \\n                  (chunk-cycle-partition chunk-size the-state)))))" "(defn run-chunks [the-steps the-stepper the-state chunk-size]\\n  (take the-steps \\n    (iterate \#(chunkerator the-stepper % chunk-size) the-state)))" "(def initial-conditions (core/make-initial-conditions 100000))" "(time (take 20 \\n        (drop 49990 \\n          (last \\n            (run-chunks 10 \\n              rule30-chunk-stepper initial-conditions 1000)))))" "(clojure.core/in-ns 'automata.rule30)\\n(def initial-conditions (core/make-initial-conditions 100000))\\n(clojure.core/in-ns 'automata.par)" "(clojure.core/in-ns 'automata.rule30)\\n(time (take 20 \\n          (drop 49990 \\n            (last (core/run-steps 10 rule-30-stepper initial-conditions)))))\\n(clojure.core/in-ns 'automata.par)" "(doc partition)" "(doc partial)" "(clojure.core/in-ns 'automata.core)\\n(defn run-steps [the-steps the-stepper the-state]\\n  (take the-steps (iterate the-stepper the-state)))\\n(clojure.core/in-ns 'automata.par)" "(clojure.core/in-ns 'automata.rule30)\\n(time (take 20 \\n          (drop 49990 \\n            (last (core/run-steps 10 rule-30-stepper initial-conditions)))))\\n(clojure.core/in-ns 'automata.par)" "(clojure.core/in-ns 'automata.rule30)\\n(time (take 20 \\n          (drop 49990 \\n            (last \\n              (core/run-steps 10 \\n                rule-30-stepper initial-conditions)))))\\n(clojure.core/in-ns 'automata.par)" "(time (take 20 \\n        (drop 49990 \\n          (last \\n            (run-chunks 10 \\n              rule30-chunk-stepper initial-conditions 1000)))))" "(time (take 20 \\n        (drop 49990 \\n          (last \\n            (run-chunks 10 \\n              rule30-chunk-stepper initial-conditions 10000)))))" "(time (take 20 \\n        (drop 49990 \\n          (last \\n            (run-chunks 10 \\n              rule30-chunk-stepper initial-conditions 1000)))))" "(time (take 20 \\n        (drop 49990 \\n          (last \\n            (run-chunks 10 \\n              rule30-chunk-stepper initial-conditions 100)))))" "(time (take 20 \\n        (drop 49990 \\n          (last \\n            (run-chunks 10 \\n              rule30-chunk-stepper initial-conditions 500)))))" "(time (take 20 \\n        (drop 49990 \\n          (last \\n            (run-chunks 10 \\n              rule30-chunk-stepper initial-conditions 800)))))" "(time (take 20 \\n        (drop 49990 \\n          (last \\n            (run-chunks 10 \\n              rule30-chunk-stepper initial-conditions 900)))))" "(time (take 20 \\n        (drop 49990 \\n          (last \\n            (run-chunks 10 \\n              rule30-chunk-stepper initial-conditions 9 00)))))" "(time (take 20 \\n        (drop 49990 \\n          (last \\n            (run-chunks 10 \\n              rule30-chunk-stepper initial-conditions 900)))))" "(time (take 20 \\n        (drop 49990 \\n          (last \\n            (run-chunks 10 \\n              rule30-chunk-stepper initial-conditions 1000)))))" "(time (take 20 \\n        (drop 49990 \\n          (last \\n            (run-chunks 10 \\n              rule30-chunk-stepper initial-conditions 7500)))))" "(time (take 20 \\n        (drop 49990 \\n          (last \\n            (run-chunks 10 \\n              rule30-chunk-stepper initial-conditions 750)))))" "(time (take 20 \\n        (drop 49990 \\n          (last \\n            (run-chunks 10 \\n              rule30-chunk-stepper initial-conditions 800)))))" "(time (take 20 \\n        (drop 49990 \\n          (last \\n            (run-chunks 10 \\n              rule30-chunk-stepper initial-conditions 1000)))))" "(def initial-conditions (core/make-initial-conditions 1000000))" "(time (take 20 \\n        (drop 49990 \\n          (last \\n            (run-chunks 10 \\n              rule30-chunk-stepper initial-conditions 1000)))))" "(defn make-chunk-stepper [the-rule]\\n  (fn [the-state]\\n    (->> (drop 1 (drop-last (vec (range (count the-state)))))\\n         (pmap \#(the-rule (core/wrap-sub the-state % 3)))\\n         (vec))))" "(time (take 20 \\n        (drop 49990 \\n          (last \\n            (run-chunks 10 \\n              rule30-chunk-stepper initial-conditions 1000)))))" "(clojure.core/in-ns 'automata.rule30)\\n(time (take 20 \\n          (drop 49990 \\n            (last \\n              (core/run-steps 10 \\n                rule-30-stepper initial-conditions)))))\\n(clojure.core/in-ns 'automata.par)" "(clojure.core/in-ns 'automata.rule30)\\n(def initial-conditions (core/make-initial-conditions 100000))\\n(clojure.core/in-ns 'automata.par)" "(clojure.core/in-ns 'automata.rule30)\\n(time (take 20 \\n          (drop 49990 \\n            (last \\n              (core/run-steps 10 \\n                rule-30-stepper initial-conditions)))))\\n(clojure.core/in-ns 'automata.par)" "(clojure.core/in-ns 'automata.rule30)\\n(def initial-conditions (core/make-initial-conditions 1000000))\\n(clojure.core/in-ns 'automata.par)" "(clojure.core/in-ns 'automata.rule30)\\n(time (take 20 \\n          (drop 49990 \\n            (last \\n              (core/run-steps 10 \\n                rule-30-stepper initial-conditions)))))\\n(clojure.core/in-ns 'automata.par)" "(def rule30-chunk-stepper\\n  (make-chunk-stepper rules/rule30))" "(clojure.core/in-ns 'automata.pimage)\\n(def initial-conditions (core/make-initial-conditions 1000))\\n(clojure.core/in-ns 'automata.par)" "(clojure.core/in-ns 'automata.print-image)\\n(ns automata.print-image\\n  (\:require [automata.core \:as core]))\\n(clojure.core/in-ns 'automata.par)" "(clojure.core/in-ns 'automata.print-image)\\n(ns automata.pimage\\n  (\:import (java.awt.image BufferedImage)\\n           (javax.imageio ImageIO)\\n           (java.io File)\\n           (java.awt Color))\\n  (\:require [automata.core \:as core]))\\n(clojure.core/in-ns 'automata.par)" "(clojure.core/in-ns 'automata.print-image)\\n(def initial-conditions (core/make-initial-conditions 1000))\\n(clojure.core/in-ns 'automata.par)" "(clojure.core/in-ns 'automata.print-image)\\n(defn pimg-automata [steps stepper the-state]\\n  (let [lines (core/run-automata steps stepper the-state)\\n        width (count the-state)\\n        img (create-image steps width lines)]\\n    (ImageIO/write img \\"png\\" (File. (str steps \\"x\\" width \\".png\\")))))\\n(clojure.core/in-ns 'automata.par)" "(clojure.core/in-ns 'automata.print-image)\\n(defn pimg-automata [steps stepper the-state]\\n  (let [lines (core/run-steps steps stepper the-state)\\n        width (count the-state)\\n        img (create-image steps width lines)]\\n    (ImageIO/write img \\"png\\" (File. (str steps \\"x\\" width \\".png\\")))))\\n(clojure.core/in-ns 'automata.par)" "(clojure.core/in-ns 'automata.print-image)\\n(defn create-image [steps width lines]\\n  (let [raster (rasterize steps width lines)\\n        img (BufferedImage. width steps BufferedImage/TYPE_INT_ARGB)]\\n    (doseq [[x y pixel] raster]\\n      (let [brush (if (\= pixel 1)\\n                    *black-rgb*\\n                    *white-rgb*)]\\n        (.setRGB img x y brush)))\\n    img))\\n(clojure.core/in-ns 'automata.par)" "(clojure.core/in-ns 'automata.print-image)\\n(assert (\= (rasterize 2 3 [[0 1 0] [1 1 1]])\\n           [[0 0 0] [1 0 1] [2 0 0]\\n            [0 1 1] [1 1 1] [2 1 1]]))\\n(clojure.core/in-ns 'automata.par)" "(clojure.core/in-ns 'automata.print-image)\\n(def *black-rgb* (.getRGB Color/BLACK))\\n(clojure.core/in-ns 'automata.par)" "(clojure.core/in-ns 'automata.print-image)\\n(def *white-rgb* (.getRGB Color/WHITE))\\n(clojure.core/in-ns 'automata.par)" "(clojure.core/in-ns 'automata.print-image)\\n(ns automata.print-image\\n  (\:require [automata.core \:as core])\\n  (\:import (java.awt.image BufferedImage)\\n           (javax.imageio ImageIO)\\n           (java.io File)\\n           (java.awt Color))\\n  (\:require [automata.core \:as core]))\\n(clojure.core/in-ns 'automata.par)" "(clojure.core/in-ns 'automata.print-image)\\n(def *black-rgb* (.getRGB Color/BLACK))\\n(clojure.core/in-ns 'automata.par)" "(clojure.core/in-ns 'automata.print-image)\\n(def *white-rgb* (.getRGB Color/WHITE))\\n(clojure.core/in-ns 'automata.par)" "(clojure.core/in-ns 'automata.print-image)\\n(defn rasterize\\n  \\"From [[0 1 0] [1 1 1] ...] to [[x y pixel] ...]\\"\\n  [steps width lines]\\n  (map (fn [[x y] pixel] [x y pixel])\\n       (for [y (range steps)\\n             x (range width)]\\n         [x y])\\n       (apply concat lines)))\\n(clojure.core/in-ns 'automata.par)" "(clojure.core/in-ns 'automata.print-image)\\n(assert (\= (rasterize 2 3 [[0 1 0] [1 1 1]])\\n           [[0 0 0] [1 0 1] [2 0 0]\\n            [0 1 1] [1 1 1] [2 1 1]]))\\n(clojure.core/in-ns 'automata.par)" "(clojure.core/in-ns 'automata.print-image)\\n(defn create-image [steps width lines]\\n  (let [raster (rasterize steps width lines)\\n        img (BufferedImage. width steps BufferedImage/TYPE_INT_ARGB)]\\n    (doseq [[x y pixel] raster]\\n      (let [brush (if (\= pixel 1)\\n                    *black-rgb*\\n                    *white-rgb*)]\\n        (.setRGB img x y brush)))\\n    img))\\n(clojure.core/in-ns 'automata.par)" "(clojure.core/in-ns 'automata.print-image)\\n(defn pimg-automata [steps stepper the-state]\\n  (let [lines (core/run-steps steps stepper the-state)\\n        width (count the-state)\\n        img (create-image steps width lines)]\\n    (ImageIO/write img \\"png\\" (File. (str steps \\"x\\" width \\".png\\")))))\\n(clojure.core/in-ns 'automata.par)" "(clojure.core/in-ns 'automata.print-image)\\n(def initial-conditions (core/make-initial-conditions 1000))\\n(clojure.core/in-ns 'automata.par)" "(clojure.core/in-ns 'automata.print-image)\\n(pimg-automata 1000 rule30 initial-conditions)\\n(clojure.core/in-ns 'automata.par)" "(clojure.core/in-ns 'automata.print-image)\\n(ns automata.print-image\\n  (\:require [automata.core \:as core]\\n            [automata.rules \:as rules])\\n  (\:import (java.awt.image BufferedImage)\\n           (javax.imageio ImageIO)\\n           (java.io File)\\n           (java.awt Color))\\n  (\:require [automata.core \:as core]))\\n(clojure.core/in-ns 'automata.par)" "(pimg-automata 1000 rules/rule30 initial-conditions)" "(clojure.core/in-ns 'automata.rules)\\n(def rule250 (core/make-rule 1 1 1 1 1 0 1 0))\\n(clojure.core/in-ns 'automata.print-image)" ";; Loading file src\\\\automata\\\\rules.clj" "(clojure.lang.Compiler/load (java.io.StringReader. \\"(ns automata.rules\\\\n  (\:require [automata.core \:as core]))\\\\n\\\\n(def rule30 (core/make-rule 0 0 0 1 1 1 1 0))\\\\n\\\\n(def rule-30-stepper\\\\n  (core/make-stepper rule30))\\\\n\\\\n(def rule90 (core/make-rule 0 1 0 1 1 0 1 0))\\\\n\\\\n(def rule-90-stepper\\\\n  (core/make-stepper rule90))\\\\n\\\\n(def rule250 (core/make-rule 1 1 1 1 1 0 1 0))\\\\n\\\\n(def rule-250-stepper\\\\n  (core/make-stepper rule250))\\\\n\\\\n\\\\n;(comment\\\\n  (def initial-conditions (core/make-initial-conditions 1000000))\\\\n  (time (take 20 \\\\n          (drop 49990 \\\\n            (last \\\\n              (core/run-steps 10 \\\\n                rule-30-stepper initial-conditions)))))\\\\n;)\\\\n\\") \\"C\:\\\\\\\\Users\\\\\\\\John\\\\\\\\workspace\\\\\\\\automata\\\\\\\\src\\\\\\\\automata\\\\\\\\rules.clj\\" \\"C\:\\\\\\\\Users\\\\\\\\John\\\\\\\\workspace\\\\\\\\automata\\\\\\\\src\\")" "(ccw.debug.serverrepl/with-exception-serialization (clojure.core/binding [clojure.core/*compile-path* \\"classes\\"] (clojure.core/compile 'automata.rules)))" "(clojure.core/in-ns 'automata.print-image)\\n(ns automata.print-image\\n  (\:require [automata.core \:as core]\\n            [automata.rules \:as rules])\\n  (\:import (java.awt.image BufferedImage)\\n           (javax.imageio ImageIO)\\n           (java.io File)\\n           (java.awt Color))\\n  (\:require [automata.core \:as core]))\\n(clojure.core/in-ns 'automata.par)" "(clojure.core/in-ns 'automata.print-image)\\n(pimg-automata 1000 rules/rule30 initial-conditions)\\n(clojure.core/in-ns 'automata.par)" "(core/run-steps 1000 rules/rule30 initial-conditions)" "(pimg-automata 1000 rules/rule-30-stepper initial-conditions)" "(pimg-automata 1000 rules/rule-90-stepper initial-conditions)" "(pimg-automata 1000 rules/rule-250-stepper initial-conditions)" "(pimg-automata 1000 rules/rule-9-stepper initial-conditions)" "(pimg-automata 1000 rules/rule-90-stepper initial-conditions)" "(def initial-conditions (core/make-initial-conditions 100))" "(pimg-automata 100 rules/rule-90-stepper initial-conditions)" "(def initial-conditions (core/make-initial-conditions 90))" "(pimg-automata 90 rules/rule-90-stepper initial-conditions)" "(def initial-conditions (core/make-initial-conditions 400))" "(pimg-automata 400 rules/rule-90-stepper initial-conditions)" "(pimg-automata 400 rules/rule-30-stepper initial-conditions)" "(clojure.core/in-ns 'automata.pfile)\\n(def initial-conditions (core/make-initial-conditions 300))\\n(clojure.core/in-ns 'automata.print-image)" "(clojure.core/in-ns 'automata.pfile)\\n(ns automata.pfile\\n  (\:require [automata.core \:as core]\\n            [automata.rules \:as rules]))\\n(clojure.core/in-ns 'automata.print-image)" "(clojure.core/in-ns 'automata.pfile)\\n(defn pp-automata [output]\\n  (let [to-pretty-char {0 \\" \\" 1 \\"\#\\"}]\\n    (doseq [line output]\\n      (println (apply str (map to-pretty-char line))))))\\n(clojure.core/in-ns 'automata.print-image)" "(clojure.core/in-ns 'automata.pfile)\\n(defn pfile-automata [output filename]\\n  (->> (with-out-str (pp-automata output))\\n       (spit filename)))\\n(clojure.core/in-ns 'automata.print-image)" "(clojure.core/in-ns 'automata.pfile)\\n(def initial-conditions (core/make-initial-conditions 300))\\n(clojure.core/in-ns 'automata.print-image)" "(clojure.core/in-ns 'automata.pfile)\\n(pfile-automata (core/run-steps 300 rules/rule-30-stepper initial-conditions) \\n  \\"150x300.txt\\")\\n(clojure.core/in-ns 'automata.print-image)" ";; Loading file src\\\\automata\\\\pfile.clj" "(clojure.lang.Compiler/load (java.io.StringReader. \\"(ns automata.pfile\\\\n  (\:require [automata.core \:as core]\\\\n            [automata.rules \:as rules]))\\\\n\\\\n(defn pp-automata [output]\\\\n  (let [to-pretty-char {0 \\\\\\" \\\\\\" 1 \\\\\\"\#\\\\\\"}]\\\\n    (doseq [line output]\\\\n      (println (apply str (map to-pretty-char line))))))\\\\n\\\\n(defn pfile-automata [output filename]\\\\n  (->> (with-out-str (pp-automata output))\\\\n       (spit filename)))\\\\n(comment\\\\n(def initial-conditions (core/make-initial-conditions 300))\\\\n(pfile-automata (core/run-steps 300 rules/rule-30-stepper initial-conditions) \\\\n  \\\\\\"300x300.txt\\\\\\")\\\\n)\\") \\"C\:\\\\\\\\Users\\\\\\\\John\\\\\\\\workspace\\\\\\\\automata\\\\\\\\src\\\\\\\\automata\\\\\\\\pfile.clj\\" \\"C\:\\\\\\\\Users\\\\\\\\John\\\\\\\\workspace\\\\\\\\automata\\\\\\\\src\\")" "(clojure.core/in-ns 'automata.pfile)\\n(pfile-automata (core/run-steps 300 rules/rule-90-stepper initial-conditions) \\n  \\"rule90-300x300.txt\\")\\n(clojure.core/in-ns 'automata.print-image)" "(clojure.core/in-ns 'automata.pfile)\\n(pfile-automata (core/run-steps 300 rules/rule-30-stepper initial-conditions) \\n  \\"rule30-300x300.txt\\")\\n(clojure.core/in-ns 'automata.print-image)" "(.toString rules/rule30)" "(name rules/rule30)" "(key rules/rule30)" "(symbol rules/rule30)" "(identity rules/rule30)" "('rules/rule30)" "'rules/rule30" "'sdf" "rule-30-stepper" "rules/rule-30-stepper" "(class rules/rule-30-stepper)" "rules/rule-30-stepper" "`rules/rule-30-stepper" "~rules/rule-30-stepper" "rules/rule-30-stepper" "(defn pimg-automata [steps stepper the-state]\\n  (let [lines (core/run-steps steps stepper the-state)\\n        width (count the-state)\\n        img (create-image steps width lines)]\\n    (ImageIO/write img \\"png\\" \\n      (File. (str `stepper \\"_\\" steps \\"x\\" width \\".png\\")))))" "(def initial-conditions (core/make-initial-conditions 300))" "(pimg-automata 300 rules/rule-30-stepper initial-conditions)" "(defn pimg-automata [steps stepper the-state]\\n  (let [lines (core/run-steps steps stepper the-state)\\n        width (count the-state)\\n        img (create-image steps width lines)]\\n    (ImageIO/write img \\"png\\" \\n      (File. (str steps \\"x\\" width \\".png\\")))))" "(pimg-automata 300 rules/rule-30-stepper initial-conditions)" "(defn pimg-automata [steps stepper the-state]\\n  (let [lines (core/run-steps steps stepper the-state)\\n        width (count the-state)\\n        img (create-image steps width lines)]\\n    (ImageIO/write img \\"png\\" \\n      (File. (str steps \\"x\\" width \\"_\\" `stepper \\".png\\")))))" "(pimg-automata 300 rules/rule-30-stepper initial-conditions)" "(defn pimg-automata [steps stepper the-state]\\n  (let [lines (core/run-steps steps stepper the-state)\\n        width (count the-state)\\n        img (create-image steps width lines)]\\n    (ImageIO/write img \\"png\\" \\n      (File. (str steps \\"x\\" width \\"_\\" ~stepper \\".png\\")))))" "(pimg-automata 300 rules/rule-30-stepper initial-conditions)" "(meta rules/rule-30-stepper)" "(clojure.core/in-ns 'automata.rules)\\n(with-meta rule30 {\:rule 30 \:name 'rule30})\\n(clojure.core/in-ns 'automata.print-image)" "(clojure.core/in-ns 'automata.rules)\\n(def rule-30-stepper\\n  (core/make-stepper rule30))\\n(clojure.core/in-ns 'automata.print-image)" "(meta rules/rule-30-stepper)" "(meta rules/rule30)" ";; Loading file src\\\\automata\\\\rules.clj" "(clojure.lang.Compiler/load (java.io.StringReader. \\"(ns automata.rules\\\\n  (\:require [automata.core \:as core]))\\\\n\\\\n(def rule30 (core/make-rule 0 0 0 1 1 1 1 0))\\\\n\\\\n(with-meta rule30 {\:rule 30 \:name 'rule30})\\\\n\\\\n(def rule-30-stepper\\\\n  (core/make-stepper rule30))\\\\n\\\\n(def rule90 (core/make-rule 0 1 0 1 1 0 1 0))\\\\n\\\\n(def rule-90-stepper\\\\n  (core/make-stepper rule90))\\\\n\\\\n(def rule250 (core/make-rule 1 1 1 1 1 0 1 0))\\\\n\\\\n(def rule-250-stepper\\\\n  (core/make-stepper rule250))\\\\n\\\\n\\\\n(comment\\\\n  (def initial-conditions (core/make-initial-conditions 1000000))\\\\n  (time (take 20 \\\\n          (drop 49990 \\\\n            (last \\\\n              (core/run-steps 10 \\\\n                rule-30-stepper initial-conditions)))))\\\\n)\\\\n\\") \\"C\:\\\\\\\\Users\\\\\\\\John\\\\\\\\workspace\\\\\\\\automata\\\\\\\\src\\\\\\\\automata\\\\\\\\rules.clj\\" \\"C\:\\\\\\\\Users\\\\\\\\John\\\\\\\\workspace\\\\\\\\automata\\\\\\\\src\\")" "(ccw.debug.serverrepl/with-exception-serialization (clojure.core/binding [clojure.core/*compile-path* \\"classes\\"] (clojure.core/compile 'automata.rules)))" "(meta rules/rule30)" "(clojure.core/in-ns 'automata.rules)\\n(with-meta rule30 {\:rule 30 \:name 'rule30})\\n(clojure.core/in-ns 'automata.print-image)" "(meta rules/rule30)" "(clojure.core/in-ns 'automata.rules)\\n(def rule30 (core/make-rule 0 0 0 1 1 1 1 0))\\n(clojure.core/in-ns 'automata.print-image)" "(clojure.core/in-ns 'automata.rules)\\n(def rule30 (with-meta rule30 {\:rule 30 \:name 'rule30})\\n(clojure.core/in-ns 'automata.print-image)" "(def rule30 (with-meta rule30 {\:rule 30 \:name 'rule30}))" "(meta rules/rule30)" "(clojure.core/in-ns 'automata.print-image)\\n(ns automata.print-image\\n  (\:require [automata.core \:as core]\\n            [automata.rules \:as rules])\\n  (\:import (java.awt.image BufferedImage)\\n           (javax.imageio ImageIO)\\n           (java.io File)\\n           (java.awt Color))\\n  (\:require [automata.core \:as core]\\n            [automata.rules \:as rules]))\\n(clojure.core/in-ns 'automata.rules)" "(meta rules/rule30)" "(clojure.core/in-ns 'automata.print-image)\\n(ns automata.print-image\\n  (\:require [automata.core \:as core]\\n            [automata.rules \:as rules])\\n  (\:import (java.awt.image BufferedImage)\\n           (javax.imageio ImageIO)\\n           (java.io File)\\n           (java.awt Color))\\n  (\:require [automata.core \:as core]\\n            [automata.rules \:as rules]))\\n(clojure.core/in-ns 'automata.rules)" ";; Switching to automata.print-image namespace" "(clojure.core/in-ns 'automata.print-image)" "(meta rules/rule30)" "(meta rules/rule-30-stepper)" "(clojure.core/in-ns 'automata.rules)\\n(def rule-30-stepper\\n  (core/make-stepper rule30))\\n(clojure.core/in-ns 'automata.print-image)" "(meta rules/rule-30-stepper)" "(clojure.core/in-ns 'automata.rules)\\n(def rule-30-stepper\\n  (with-meta rule-30-stepper {\:rule-name 'rule30}))\\n(clojure.core/in-ns 'automata.print-image)" "(meta rules/rule-30-stepper)" "(defn pimg-automata [steps stepper the-state]\\n  (let [lines (core/run-steps steps stepper the-state)\\n        width (count the-state)\\n        img (create-image steps width lines)]\\n    (ImageIO/write img \\"png\\" \\n      (File. (str steps \\"x\\" width \\"_\\" (\:rule-name (meta stepper)) \\".png\\")))))" "(pimg-automata 300 rules/rule-30-stepper initial-conditions)" "(clojure.core/in-ns 'automata.rules)\\n(def rule30 \\n  (with-meta\\n    (core/make-rule 0 0 0 1 1 1 1 0)\\n    {\:rule 30 \:name 'rule30})\\n(clojure.core/in-ns 'automata.print-image)" "(def rule30 \\n  (with-meta\\n    (core/make-rule 0 0 0 1 1 1 1 0)\\n    {\:rule 30 \:name 'rule30}))" "(meta rules/rule30)" "(meta rule30)" "(def rule30 \\n  (with-meta\\n    (core/make-rule 0 0 0 1 1 1 1 0)\\n    {\:rule 30 \:name 'rule30}))" "(meta rule30)" "(def rule30 \\n  (with-meta\\n    (core/make-rule 0 0 0 1 1 1 1 0)\\n    {\:rule 31 \:name 'rule30}))" "(meta rule30)" "^rule30" "^\#rule30" "\#^rule30" "(\#^rule30)" "(meta \#^rule30)" "(meta \#'rule30)" "\#'rule30" "(meta \#'rule30)" "(meta \#'rule90)" "(clojure.core/in-ns 'automata.print-image)\\n(defn pimg-automata [steps stepper the-state]\\n  (let [lines (core/run-steps steps stepper the-state)\\n        width (count the-state)\\n        img (create-image steps width lines)]\\n    (ImageIO/write img \\"png\\" \\n      (File. (str steps \\"x\\" width \\"_\\" (\:name (meta \#'stepper)) \\".png\\")))))\\n(clojure.core/in-ns 'automata.rules)" "(meta \#'rule90)" "(meta \#rule90)" "(meta \#' rule90)" "(clojure.core/in-ns 'automata.print-image)\\n(defn pimg-automata [steps stepper the-state]\\n  (let [lines (core/run-steps steps stepper the-state)\\n        width (count the-state)\\n        img (create-image steps width lines)]\\n    (ImageIO/write img \\"png\\" \\n      (File. (str steps \\"x\\" width \\"_\\" (\:name (meta \#' stepper)) \\".png\\")))))\\n(clojure.core/in-ns 'automata.rules)" "(clojure.core/in-ns 'automata.print-image)\\n(ns automata.print-image\\n  (\:require [automata.core \:as core]\\n            [automata.rules \:as rules])\\n  (\:import (java.awt.image BufferedImage)\\n           (javax.imageio ImageIO)\\n           (java.io File)\\n           (java.awt Color))\\n  (\:require [automata.core \:as core]\\n            [automata.rules \:as rules]))\\n(clojure.core/in-ns 'automata.rules)" "(clojure.core/in-ns 'automata.print-image)\\n(def *black-rgb* (.getRGB Color/BLACK))\\n(clojure.core/in-ns 'automata.rules)" "(clojure.core/in-ns 'automata.print-image)\\n(def *white-rgb* (.getRGB Color/WHITE))\\n(clojure.core/in-ns 'automata.rules)" "(clojure.core/in-ns 'automata.print-image)\\n(defn rasterize\\n  \\"From [[0 1 0] [1 1 1] ...] to [[x y pixel] ...]\\"\\n  [steps width lines]\\n  (map (fn [[x y] pixel] [x y pixel])\\n       (for [y (range steps)\\n             x (range width)]\\n         [x y])\\n       (apply concat lines)))\\n(clojure.core/in-ns 'automata.rules)" "(clojure.core/in-ns 'automata.print-image)\\n(assert (\= (rasterize 2 3 [[0 1 0] [1 1 1]])\\n           [[0 0 0] [1 0 1] [2 0 0]\\n            [0 1 1] [1 1 1] [2 1 1]]))\\n(clojure.core/in-ns 'automata.rules)" "(clojure.core/in-ns 'automata.print-image)\\n(defn create-image [steps width lines]\\n  (let [raster (rasterize steps width lines)\\n        img (BufferedImage. width steps BufferedImage/TYPE_INT_ARGB)]\\n    (doseq [[x y pixel] raster]\\n      (let [brush (if (\= pixel 1)\\n                    *black-rgb*\\n                    *white-rgb*)]\\n        (.setRGB img x y brush)))\\n    img))\\n(clojure.core/in-ns 'automata.rules)" "(clojure.core/in-ns 'automata.print-image)\\n(defn pimg-automata [steps stepper the-state]\\n  (let [lines (core/run-steps steps stepper the-state)\\n        width (count the-state)\\n        img (create-image steps width lines)]\\n    (ImageIO/write img \\"png\\" \\n      (File. (str steps \\"x\\" width \\"_\\" (\:name (meta \#' stepper)) \\".png\\")))))\\n(clojure.core/in-ns 'automata.rules)" "(clojure.core/in-ns 'automata.print-image)\\n(defn pimg-automata [steps stepper the-state]\\n  (let [lines (core/run-steps steps stepper the-state)\\n        width (count the-state)\\n        img (create-image steps width lines)]\\n    (ImageIO/write img \\"png\\" \\n      (File. (str steps \\"x\\" width \\"_\\" (\:name (meta  stepper)) \\".png\\")))))\\n(clojure.core/in-ns 'automata.rules)" "(clojure.core/in-ns 'automata.print-image)\\n(defn pimg-automata [steps stepper the-state]\\n  (let [lines (core/run-steps steps stepper the-state)\\n        width (count the-state)\\n        img (create-image steps width lines)]\\n    (ImageIO/write img \\"png\\" \\n      (File. (str steps \\"x\\" width \\"_\\" (\:name (meta \#' stepper)) \\".png\\")))))\\n(clojure.core/in-ns 'automata.rules)" "(clojure.core/in-ns 'automata.print-image)\\n(defn pimg-automata [steps stepper the-state]\\n  (let [lines (core/run-steps steps stepper the-state)\\n        width (count the-state)\\n        img (create-image steps width lines)]\\n    (ImageIO/write img \\"png\\" \\n      (File. (str steps \\"x\\" width \\"_\\" (\:name (meta \#` stepper)) \\".png\\")))))\\n(clojure.core/in-ns 'automata.rules)" "(clojure.core/in-ns 'automata.print-image)\\n(defn pimg-automata [steps stepper the-state]\\n  (let [lines (core/run-steps steps stepper the-state)\\n        width (count the-state)\\n        img (create-image steps width lines)]\\n    (ImageIO/write img \\"png\\" \\n      (File. (str steps \\"x\\" width \\"_\\" (\:name (meta \#' stepper')) \\".png\\")))))\\n(clojure.core/in-ns 'automata.rules)" "(clojure.core/in-ns 'automata.print-image)\\n(defn pimg-automata [steps stepper the-state]\\n  (let [lines (core/run-steps steps stepper the-state)\\n        width (count the-state)\\n        img (create-image steps width lines)]\\n    (ImageIO/write img \\"png\\" \\n      (File. (str steps \\"x\\" width \\"_\\" (\:name (meta \#' stepper)) \\".png\\")))))\\n(clojure.core/in-ns 'automata.rules)" "(clojure.core/in-ns 'automata.print-image)\\n(defn pimg-automata [steps stepper the-state]\\n  (let [lines (core/run-steps steps stepper the-state)\\n        width (count the-state)\\n        img (create-image steps width lines)]\\n    (ImageIO/write img \\"png\\" \\n      (File. (str steps \\"x\\" width \\"_\\" (\:name (meta \#'stepper)) \\".png\\")))))\\n(clojure.core/in-ns 'automata.rules)" "(clojure.core/in-ns 'automata.print-image)\\n(pimg-automata 300 rules/rule-30-stepper initial-conditions)\\n(clojure.core/in-ns 'automata.rules)" "(meta \#' rule90)" "(\:name (meta \#'rule90))" "(\:name (meta ~\#'rule90))" "(clojure.core/in-ns 'automata.print-image)\\n(defn pimg-automata [steps stepper the-state]\\n  (let [lines (core/run-steps steps stepper the-state)\\n        width (count the-state)\\n        img (create-image steps width lines)]\\n    (ImageIO/write img \\"png\\" \\n      (File. (str steps \\"x\\" width \\"_\\" (\:name (meta ~\#'stepper)) \\".png\\")))))\\n(clojure.core/in-ns 'automata.rules)" "(clojure.core/in-ns 'automata.print-image)\\n(defn pimg-automata [steps stepper the-state]\\n  (let [lines (core/run-steps steps stepper the-state)\\n        width (count the-state)\\n        img (create-image steps width lines)]\\n    (ImageIO/write img \\"png\\" \\n      (File. (str steps \\"x\\" width \\"_\\" (\:name (meta `\#'stepper)) \\".png\\")))))\\n(clojure.core/in-ns 'automata.rules)" "(clojure.core/in-ns 'automata.print-image)\\n(pimg-automata 300 rules/rule-30-stepper initial-conditions)\\n(clojure.core/in-ns 'automata.rules)" "(\:name (meta `\#'rule90))" "`\#'rule90" "\#'rule90" "(take 2 \#'rule90)" "(\:name \#'rule90)" "\#'rule90" "(^\#'rule90)" "(^ \#'rule90)" "(meta \#'rule90)" "(clojure.core/in-ns 'automata.print-image)\\n(defn pimg-automata [steps stepper the-state]\\n  (let [lines (core/run-steps steps stepper the-state)\\n        width (count the-state)\\n        img (create-image steps width lines)]\\n    (ImageIO/write img \\"png\\" \\n      (File. (str steps \\"x\\" width \\"_\\" (\:name (meta \#'stepper)) \\".png\\")))))\\n(clojure.core/in-ns 'automata.rules)" "(~rule90)" "(`rule90)" "`rule90" "(clojure.core/in-ns 'automata.print-image)\\n(defn pimg-automata [steps stepper the-state]\\n  (let [lines (core/run-steps steps stepper the-state)\\n        width (count the-state)\\n        img (create-image steps width lines)]\\n    (ImageIO/write img \\"png\\" \\n      (File. (str steps \\"x\\" width \\"_\\" (\:name (meta \#'`stepper)) \\".png\\")))))\\n(clojure.core/in-ns 'automata.rules)" "(clojure.core/in-ns 'automata.print-image)\\n(defn pimg-automata [steps stepper the-state]\\n  (let [lines (core/run-steps steps stepper the-state)\\n        width (count the-state)\\n        img (create-image steps width lines)]\\n    (ImageIO/write img \\"png\\" \\n      (File. (str steps \\"x\\" width \\"_\\" (\:name (meta \#`stepper)) \\".png\\")))))\\n(clojure.core/in-ns 'automata.rules)" "(clojure.core/in-ns 'automata.print-image)\\n(defn pimg-automata [steps stepper the-state]\\n  (let [lines (core/run-steps steps stepper the-state)\\n        width (count the-state)\\n        img (create-image steps width lines)]\\n    (ImageIO/write img \\"png\\" \\n      (File. (str steps \\"x\\" width \\"_\\" (\:name (meta \#`'stepper)) \\".png\\")))))\\n(clojure.core/in-ns 'automata.rules)" "(clojure.core/in-ns 'automata.print-image)\\n(defn pimg-automata [steps stepper the-state]\\n  (let [lines (core/run-steps steps stepper the-state)\\n        width (count the-state)\\n        img (create-image steps width lines)]\\n    (ImageIO/write img \\"png\\" \\n      (File. (str steps \\"x\\" width \\"_\\" (\:name (meta \#' `stepper)) \\".png\\")))))\\n(clojure.core/in-ns 'automata.rules)" "(clojure.core/in-ns 'automata.print-image)\\n(defn pimg-automata [steps stepper the-state]\\n  (let [lines (core/run-steps steps stepper the-state)\\n        width (count the-state)\\n        img (create-image steps width lines)]\\n    (ImageIO/write img \\"png\\" \\n      (File. (str steps \\"x\\" width \\"_\\" (\:name (meta \#' ~stepper)) \\".png\\")))))\\n(clojure.core/in-ns 'automata.rules)" "(clojure.core/in-ns 'automata.print-image)\\n(defn pimg-automata [steps stepper the-state]\\n  (let [lines (core/run-steps steps stepper the-state)\\n        width (count the-state)\\n        img (create-image steps width lines)]\\n    (ImageIO/write img \\"png\\" \\n      (File. (str steps \\"x\\" width \\"_\\" (\:name (meta \#' stepper)) \\".png\\")))))\\n(clojure.core/in-ns 'automata.rules)" "(clojure.core/in-ns 'automata.print-image)\\n(defn pimg-automata [steps stepper the-state]\\n  (let [lines (core/run-steps steps stepper the-state)\\n        width (count the-state)\\n        img (create-image steps width lines)]\\n    (ImageIO/write img \\"png\\" \\n      (File. (str steps \\"x\\" width \\"_\\" (\:name (meta \#' ~stepper)) \\".png\\")))))\\n(clojure.core/in-ns 'automata.rules)" "(resolve rule90)" "(resolve 'rule90)" "(clojure.core/in-ns 'automata.print-image)\\n(defn pimg-automata [steps stepper the-state]\\n  (let [lines (core/run-steps steps stepper the-state)\\n        width (count the-state)\\n        img (create-image steps width lines)]\\n    (ImageIO/write img \\"png\\" \\n      (File. (str steps \\"x\\" width \\"_\\" (\:name (meta \#'(resove stepper))) \\".png\\")))))\\n(clojure.core/in-ns 'automata.rules)" "(clojure.core/in-ns 'automata.print-image)\\n(defn pimg-automata [steps stepper the-state]\\n  (let [lines (core/run-steps steps stepper the-state)\\n        width (count the-state)\\n        img (create-image steps width lines)]\\n    (ImageIO/write img \\"png\\" \\n      (File. (str steps \\"x\\" width \\"_\\" (\:name (meta \#' (resove stepper))) \\".png\\")))))\\n(clojure.core/in-ns 'automata.rules)" "(clojure.core/in-ns 'automata.print-image)\\n(defn pimg-automata [steps stepper the-state]\\n  (let [lines (core/run-steps steps stepper the-state)\\n        width (count the-state)\\n        img (create-image steps width lines)]\\n    (ImageIO/write img \\"png\\" \\n      (File. (str steps \\"x\\" width \\"_\\" (\:name (meta \#' (resove 'stepper))) \\".png\\")))))\\n(clojure.core/in-ns 'automata.rules)" "(clojure.core/in-ns 'automata.print-image)\\n(defn pimg-automata [steps stepper the-state]\\n  (let [lines (core/run-steps steps stepper the-state)\\n        width (count the-state)\\n        img (create-image steps width lines)]\\n    (ImageIO/write img \\"png\\" \\n      (File. (str steps \\"x\\" width \\"_\\" (\:name (meta  (resove 'stepper))) \\".png\\")))))\\n(clojure.core/in-ns 'automata.rules)" "(clojure.core/in-ns 'automata.print-image)\\n(defn pimg-automata [steps stepper the-state]\\n  (let [lines (core/run-steps steps stepper the-state)\\n        width (count the-state)\\n        img (create-image steps width lines)]\\n    (ImageIO/write img \\"png\\" \\n      (File. (str steps \\"x\\" width \\"_\\" (\:name (meta  (resolve 'stepper))) \\".png\\")))))\\n(clojure.core/in-ns 'automata.rules)" "(clojure.core/in-ns 'automata.print-image)\\n(pimg-automata 300 rules/rule-30-stepper initial-conditions)\\n(clojure.core/in-ns 'automata.rules)" "(meta (resolve 'rule90))" "(\:name (meta (resolve 'rule90)))" "(clojure.core/in-ns 'automata.print-image)\\n(defn pimg-automata [steps stepper the-state]\\n  (let [lines (core/run-steps steps stepper the-state)\\n        width (count the-state)\\n        img (create-image steps width lines)]\\n    (ImageIO/write img \\"png\\" \\n      (File. (str steps \\"x\\" width \\"_\\" (\:name (meta (resolve 'stepper))) \\".png\\")))))\\n(clojure.core/in-ns 'automata.rules)" "(clojure.core/in-ns 'automata.print-image)\\n(pimg-automata 300 rules/rule-30-stepper initial-conditions)\\n(clojure.core/in-ns 'automata.rules)" "(clojure.core/in-ns 'automata.print-image)\\n(defn pimg-automata [steps stepper the-state]\\n  (let [lines (core/run-steps steps stepper the-state)\\n        width (count the-state)\\n        img (create-image steps width lines)\\n        the-name (\:name (meta (resolve 'stepper)))]\\n    (ImageIO/write img \\"png\\" \\n      (File. (str steps \\"x\\" width \\"_\\" the-name \\".png\\")))))\\n(clojure.core/in-ns 'automata.rules)" "(clojure.core/in-ns 'automata.print-image)\\n(pimg-automata 300 rules/rule-30-stepper initial-conditions)\\n(clojure.core/in-ns 'automata.rules)" "(clojure.core/in-ns 'automata.print-image)\\n(defn pimg-automata [steps stepper the-state]\\n  (let [lines (core/run-steps steps stepper the-state)\\n        width (count the-state)\\n        img (create-image steps width lines)\\n        the-name (\:name (meta (resolve 'stepper)))\\n        _ (println the-name)]\\n    (ImageIO/write img \\"png\\" \\n      (File. (str steps \\"x\\" width \\"_\\" the-name \\".png\\")))))\\n(clojure.core/in-ns 'automata.rules)" "(clojure.core/in-ns 'automata.print-image)\\n(pimg-automata 300 rules/rule-30-stepper initial-conditions)\\n(clojure.core/in-ns 'automata.rules)" "(clojure.core/in-ns 'automata.print-image)\\n(defn pimg-automata [steps stepper the-state]\\n  (let [lines (core/run-steps steps stepper the-state)\\n        width (count the-state)\\n        img (create-image steps width lines)\\n        the-name (meta (resolve 'stepper))\\n        _ (println the-name)]\\n    (ImageIO/write img \\"png\\" \\n      (File. (str steps \\"x\\" width \\"_\\" the-name \\".png\\")))))\\n(clojure.core/in-ns 'automata.rules)" "(clojure.core/in-ns 'automata.print-image)\\n(pimg-automata 300 rules/rule-30-stepper initial-conditions)\\n(clojure.core/in-ns 'automata.rules)" "(clojure.core/in-ns 'automata.print-image)\\n(defn pimg-automata [steps stepper the-state]\\n  (let [lines (core/run-steps steps stepper the-state)\\n        width (count the-state)\\n        img (create-image steps width lines)\\n        the-name (resolve 'stepper)\\n        _ (println the-name)]\\n    (ImageIO/write img \\"png\\" \\n      (File. (str steps \\"x\\" width \\"_\\" the-name \\".png\\")))))\\n(clojure.core/in-ns 'automata.rules)" "(clojure.core/in-ns 'automata.print-image)\\nnull\\n(clojure.core/in-ns 'automata.rules)" ";; Loading file src\\\\automata\\\\pimage.clj" "(clojure.lang.Compiler/load (java.io.StringReader. \\"(ns automata.print-image\\\\n  (\:require [automata.core \:as core]\\\\n            [automata.rules \:as rules])\\\\n  (\:import (java.awt.image BufferedImage)\\\\n           (javax.imageio ImageIO)\\\\n           (java.io File)\\\\n           (java.awt Color))\\\\n  (\:require [automata.core \:as core]\\\\n            [automata.rules \:as rules]))\\\\n\\\\n(def *black-rgb* (.getRGB Color/BLACK))\\\\n(def *white-rgb* (.getRGB Color/WHITE)) \\\\n\\\\n\\\\n(defn rasterize\\\\n  \\\\\\"From [[0 1 0] [1 1 1] ...] to [[x y pixel] ...]\\\\\\"\\\\n  [steps width lines]\\\\n  (map (fn [[x y] pixel] [x y pixel])\\\\n       (for [y (range steps)\\\\n             x (range width)]\\\\n         [x y])\\\\n       (apply concat lines)))\\\\n\\\\n(assert (\= (rasterize 2 3 [[0 1 0] [1 1 1]])\\\\n           [[0 0 0] [1 0 1] [2 0 0]\\\\n            [0 1 1] [1 1 1] [2 1 1]]))\\\\n\\\\n\\\\n(defn create-image [steps width lines]\\\\n  (let [raster (rasterize steps width lines)\\\\n        img (BufferedImage. width steps BufferedImage/TYPE_INT_ARGB)]\\\\n    (doseq [[x y pixel] raster]\\\\n      (let [brush (if (\= pixel 1)\\\\n                    *black-rgb*\\\\n                    *white-rgb*)]\\\\n        (.setRGB img x y brush)))\\\\n    img))\\\\n\\\\n(defn pimg-automata [steps stepper the-state]\\\\n  (let [lines (core/run-steps steps stepper the-state)\\\\n        width (count the-state)\\\\n        img (create-image steps width lines)\\\\n        the-name (resolve ~'stepper)\\\\n        _ (println the-name)]\\\\n    (ImageIO/write img \\\\\\"png\\\\\\" \\\\n      (File. (str steps \\\\\\"x\\\\\\" width \\\\\\"_\\\\\\" the-name \\\\\\".png\\\\\\")))))\\\\n\\\\n;(comment\\\\n  (def initial-conditions (core/make-initial-conditions 300))\\\\n  (pimg-automata 300 rules/rule-30-stepper initial-conditions)\\\\n ; )\\") \\"C\:\\\\\\\\Users\\\\\\\\John\\\\\\\\workspace\\\\\\\\automata\\\\\\\\src\\\\\\\\automata\\\\\\\\pimage.clj\\" \\"C\:\\\\\\\\Users\\\\\\\\John\\\\\\\\workspace\\\\\\\\automata\\\\\\\\src\\")" "(clojure.core/in-ns 'automata.print-image)\\n(defn pimg-automata [steps stepper the-state]\\n  (let [lines (core/run-steps steps stepper the-state)\\n        width (count the-state)\\n        img (create-image steps width lines)\\n        the-name (resolve (unquote stepper))\\n        _ (println the-name)]\\n    (ImageIO/write img \\"png\\" \\n      (File. (str steps \\"x\\" width \\"_\\" the-name \\".png\\")))))\\n(clojure.core/in-ns 'automata.rules)" "(clojure.core/in-ns 'automata.print-image)\\n(pimg-automata 300 rules/rule-30-stepper initial-conditions)\\n(clojure.core/in-ns 'automata.rules)" "(clojure.core/in-ns 'automata.print-image)\\n(defn pimg-automata [steps stepper the-state]\\n  (let [lines (core/run-steps steps stepper the-state)\\n        width (count the-state)\\n        img (create-image steps width lines)\\n        the-name \#'stepper\\n        _ (println the-name)]\\n    (ImageIO/write img \\"png\\" \\n      (File. (str steps \\"x\\" width \\"_\\" the-name \\".png\\")))))\\n(clojure.core/in-ns 'automata.rules)" "(clojure.core/in-ns 'automata.print-image)\\n(defn pimg-automata [steps stepper the-state]\\n  (let [lines (core/run-steps steps stepper the-state)\\n        width (count the-state)\\n        img (create-image steps width lines)\\n        the-name (var stepper)\\n        _ (println the-name)]\\n    (ImageIO/write img \\"png\\" \\n      (File. (str steps \\"x\\" width \\"_\\" the-name \\".png\\")))))\\n(clojure.core/in-ns 'automata.rules)" "(var-get rule90)" "(var-get (var rule90))" "(clojure.core/in-ns 'automata.print-image)\\n(defn pimg-automata [steps stepper the-state]\\n  (let [lines (core/run-steps steps stepper the-state)\\n        width (count the-state)\\n        img (create-image steps width lines)\\n        a-var (var stepper)\\n        the-name (meta \#'a-var)\\n        _ (println the-name)]\\n    (ImageIO/write img \\"png\\" \\n      (File. (str steps \\"x\\" width \\"_\\" the-name \\".png\\")))))\\n(clojure.core/in-ns 'automata.rules)" "(clojure.core/in-ns 'automata.print-image)\\n(defn pimg-automata [steps stepper the-state]\\n  (let [lines (core/run-steps steps stepper the-state)\\n        width (count the-state)\\n        img (create-image steps width lines)\\n        a-var stepper\\n        the-name (meta \#'a-var)\\n        _ (println the-name)]\\n    (ImageIO/write img \\"png\\" \\n      (File. (str steps \\"x\\" width \\"_\\" the-name \\".png\\")))))\\n(clojure.core/in-ns 'automata.rules)" "(clojure.core/in-ns 'automata.print-image)\\n(defn pimg-automata [steps stepper the-state]\\n  (let [lines (core/run-steps steps stepper the-state)\\n        width (count the-state)\\n        img (create-image steps width lines)\\n        a-var stepper\\n        the-name (resove stepper)\\n        _ (println the-name)]\\n    (ImageIO/write img \\"png\\" \\n      (File. (str steps \\"x\\" width \\"_\\" the-name \\".png\\")))))\\n(clojure.core/in-ns 'automata.rules)" "(clojure.core/in-ns 'automata.print-image)\\n(defn pimg-automata [steps stepper the-state]\\n  (let [lines (core/run-steps steps stepper the-state)\\n        width (count the-state)\\n        img (create-image steps width lines)\\n        a-var stepper\\n        the-name (resolve stepper)\\n        _ (println the-name)]\\n    (ImageIO/write img \\"png\\" \\n      (File. (str steps \\"x\\" width \\"_\\" the-name \\".png\\")))))\\n(clojure.core/in-ns 'automata.rules)" "(clojure.core/in-ns 'automata.print-image)\\n(pimg-automata 300 rules/rule-30-stepper initial-conditions)\\n(clojure.core/in-ns 'automata.rules)" "(clojure.core/in-ns 'automata.print-image)\\n(defn pimg-automata [steps stepper the-state]\\n  (let [lines (core/run-steps steps stepper the-state)\\n        width (count the-state)\\n        img (create-image steps width lines)\\n        a-var stepper\\n        the-name (resolve stepper)\\n        _ (println (str the-name))]\\n    (ImageIO/write img \\"png\\" \\n      (File. (str steps \\"x\\" width \\"_\\" the-name \\".png\\")))))\\n(clojure.core/in-ns 'automata.rules)" "(clojure.core/in-ns 'automata.print-image)\\n(pimg-automata 300 rules/rule-30-stepper initial-conditions)\\n(clojure.core/in-ns 'automata.rules)" "(clojure.core/in-ns 'automata.print-image)\\n(defn pimg-automata [steps stepper the-state]\\n  (let [lines (core/run-steps steps stepper the-state)\\n        width (count the-state)\\n        img (create-image steps width lines)\\n        ;a-var stepper\\n        the-name (resolve stepper)\\n        _ (println (str the-name))]\\n    (ImageIO/write img \\"png\\" \\n      (File. (str steps \\"x\\" width \\"_\\" the-name \\".png\\")))))\\n(clojure.core/in-ns 'automata.rules)" "(clojure.core/in-ns 'automata.print-image)\\n(pimg-automata 300 rules/rule-30-stepper initial-conditions)\\n(clojure.core/in-ns 'automata.rules)" "(clojure.core/in-ns 'automata.print-image)\\n(defn pimg-automata [steps stepper the-state]\\n  (let [lines (core/run-steps steps stepper the-state)\\n        width (count the-state)\\n        img (create-image steps width lines)\\n        ;a-var stepper\\n        the-name (\:name (meta (resolve stepper)))\\n        _ (println (str the-name))]\\n    (ImageIO/write img \\"png\\" \\n      (File. (str steps \\"x\\" width \\"_\\" the-name \\".png\\")))))\\n(clojure.core/in-ns 'automata.rules)" "(clojure.core/in-ns 'automata.print-image)\\n(pimg-automata 300 rules/rule-30-stepper initial-conditions)\\n(clojure.core/in-ns 'automata.rules)" "'(rule90)" "'(inc)" "`(inc)" "(meta `(inc))" "(\#' `(inc))" "(\#'`(inc))" "(var `(inc))" "`(inc)" "(clojure.core/in-ns 'automata.print-image)\\n(defn pimg-automata [steps stepper the-state]\\n  (let [lines (core/run-steps steps stepper the-state)\\n        width (count the-state)\\n        img (create-image steps width lines)\\n        ;a-var stepper\\n        ;the-name (\:name (meta (resolve stepper)))\\n        _ (println `(stepper))]\\n    (ImageIO/write img \\"png\\" \\n      (File. (str steps \\"x\\" width \\"_\\" stepper \\".png\\")))))\\n(clojure.core/in-ns 'automata.rules)" "(clojure.core/in-ns 'automata.print-image)\\n(pimg-automata 300 rules/rule-30-stepper initial-conditions)\\n(clojure.core/in-ns 'automata.rules)" "(clojure.core/in-ns 'automata.print-image)\\n(defn pimg-automata [steps stepper the-state]\\n  (let [lines (core/run-steps steps stepper the-state)\\n        width (count the-state)\\n        img (create-image steps width lines)\\n        ;a-var stepper\\n        ;the-name (\:name (meta (resolve stepper)))\\n        _ (println `(stepper))]\\n    (ImageIO/write img \\"png\\" \\n      (File. (str steps \\"x\\" width \\"_\\" (resolve 'stepper) \\".png\\")))))\\n(clojure.core/in-ns 'automata.rules)" "(clojure.core/in-ns 'automata.print-image)\\n(pimg-automata 300 rules/rule-30-stepper initial-conditions)\\n(clojure.core/in-ns 'automata.rules)" "(symbol rule90)" "^(ns-resolve 'automata.rules rule90)" "(ns-resolve 'automata.rules rule90)" "(ns-resolve 'automata.rules \\"rule90\\")" "(ns-resolve 'automata.rules 'rule90)" "(clojure.core/in-ns 'automata.print-image)\\n(defn pimg-automata [steps stepper the-state]\\n  (let [lines (core/run-steps steps stepper the-state)\\n        width (count the-state)\\n        img (create-image steps width lines)\\n        ;a-var stepper\\n        ;the-name (\:name (meta (resolve stepper)))\\n        _ (println (ns-resolve 'automata.rules 'stepper))]\\n    (ImageIO/write img \\"png\\" \\n      (File. (str steps \\"x\\" width \\"_\\" (resolve 'stepper) \\".png\\")))))\\n(clojure.core/in-ns 'automata.rules)" "(clojure.core/in-ns 'automata.print-image)\\n(pimg-automata 300 rules/rule-30-stepper initial-conditions)\\n(clojure.core/in-ns 'automata.rules)" "gensym" "(gensym)" "(clojure.core/in-ns 'automata.print-image)\\n(defn pimg-automata [steps stepper the-state]\\n  (let [lines (core/run-steps steps stepper the-state)\\n        width (count the-state)\\n        img (create-image steps width lines)]\\n    (ImageIO/write img \\"png\\" \\n      (File. (str steps \\"x\\" width \\"_\\" (gensym) \\".png\\")))))\\n(clojure.core/in-ns 'automata.rules)" "(clojure.core/in-ns 'automata.print-image)\\n(pimg-automata 300 rules/rule-30-stepper initial-conditions)\\n(clojure.core/in-ns 'automata.rules)" "(clojure.core/in-ns 'automata.print-image)\\n(pimg-automata 300 rules/rule-90-stepper initial-conditions)\\n(clojure.core/in-ns 'automata.rules)" ";; Loading file src\\\\automata\\\\rules.clj" "(clojure.lang.Compiler/load (java.io.StringReader. \\"(ns automata.rules\\\\n  (\:require [automata.core \:as core]))\\\\n\\\\n(def rule30 \\\\n  (with-meta\\\\n    (core/make-rule 0 0 0 1 1 1 1 0)\\\\n    {\:name 'rule30}))\\\\n\\\\n(def rule-30-stepper\\\\n  (core/make-stepper rule30))\\\\n\\\\n(def rule-30-stepper\\\\n  (with-meta rule-30-stepper {\:rule-name 'rule30}))\\\\n\\\\n(def rule90 (core/make-rule 0 1 0 1 1 0 1 0))\\\\n\\\\n(def rule-90-stepper\\\\n  (core/make-stepper rule90))\\\\n\\\\n(def rule250 (core/make-rule 1 1 1 1 1 0 1 0))\\\\n\\\\n(def rule-250-stepper\\\\n  (core/make-stepper rule250))\\\\n\\\\n\\\\n(comment\\\\n  (def initial-conditions (core/make-initial-conditions 1000000))\\\\n  (time (take 20 \\\\n          (drop 49990 \\\\n            (last \\\\n              (core/run-steps 10 \\\\n                rule-30-stepper initial-conditions)))))\\\\n)\\\\n\\") \\"C\:\\\\\\\\Users\\\\\\\\John\\\\\\\\workspace\\\\\\\\automata\\\\\\\\src\\\\\\\\automata\\\\\\\\rules.clj\\" \\"C\:\\\\\\\\Users\\\\\\\\John\\\\\\\\workspace\\\\\\\\automata\\\\\\\\src\\")" "(ccw.debug.serverrepl/with-exception-serialization (clojure.core/binding [clojure.core/*compile-path* \\"classes\\"] (clojure.core/compile 'automata.core)))" "(ccw.debug.serverrepl/with-exception-serialization (clojure.core/binding [clojure.core/*compile-path* \\"classes\\"] (clojure.core/compile 'automata.print-image)))" "(ccw.debug.serverrepl/with-exception-serialization (clojure.core/binding [clojure.core/*compile-path* \\"classes\\"] (clojure.core/compile 'automata.par)))" "(ccw.debug.serverrepl/with-exception-serialization (clojure.core/binding [clojure.core/*compile-path* \\"classes\\"] (clojure.core/compile 'automata.rules)))" "(ccw.debug.serverrepl/with-exception-serialization (clojure.core/binding [clojure.core/*compile-path* \\"classes\\"] (clojure.core/compile 'automata.pfile)))"]
eclipse.preferences.version=1
